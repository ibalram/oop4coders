%=====================================================================
\ifx\wholebook\relax\else
	\documentclass{KodeBook}
	\input{calls}
	\begin{document}
\fi
%=====================================================================

\chapter{Encapsulation}

\begin{introduction}
	Encapsulation is one important concept of OOP. 
	It is the mechanism of restricting direct access to some members of a class.
	It helps managing complexity when debugging source code. 
	If a field is accessed everywhere in your source code, this makes it difficult to find errors related to this field. 
	Also, if a field of a class (A) is used by a class (B) then we changed it (either its name or how it gets assigned), we have to change all the code where it appears in (B).
	In this chapter, we will show different visibility modes and how they are implemented in each language.
	You will see that there are two views: "Many programmers are irresponsible, dim-witted, or both." and "Programmers are responsible adults and capable of good judgment".
	So, a programming language may fall into one or another.
\end{introduction}

\section{Public members}

Public visibility mode is used to access a member of a class from everywhere. 
Public methods of a class provide an interface that allows them to be called so the object can afford some behavior. 
As for fields, public visibility mode is not preferable since it breaks encapsulation, and it has limited uses:
\begin{itemize}
	\item Constant fields can be exposed to the outside classes.%Joshua Bloch writes in Effective Java
	\item Classes which represent just data, and unlikely to be changed in the future.
\end{itemize}

\subsection{C++}

Public members are defined inside the class header using the modifier \keyword{public}. 
Every member coming after that modifier is considered as public.
If you use \keyword{struct} instead of \keyword{class}, all members are public by default.

\lstinputlisting[language=C++, linerange={6-7,12-15,25-25}, style=codeStyle]{../codes/cpp/encapsulation/person.h}

These members can be accessed anywhere

\lstinputlisting[language=C++, linerange={10-12, 14-14, 17-18,27-28}, style=codeStyle]{../codes/cpp/encapsulation/app.cpp}

An important remark: when you compile multiple files using g++, you have to include all cpp files
\begin{lstlisting}[style=shellStyle]
$ g++ app.cpp person.cpp student.cpp frnd.h
\end{lstlisting}

If you include a header twice or more, you may have an error telling you that you defined the class more than once. 
To correct this, you have to use \nameword{\#include guard}.

\lstinputlisting[language=C++, linerange={1-3,6-7,25-26}, style=codeStyle]{../codes/cpp/encapsulation/person.h}

\subsection{Java}

Every public member in Java must preceded by the keyword \keyword{public}. 

\lstinputlisting[language=Java, linerange={1-5,12-12,18-20,27-29}, style=codeStyle]{../codes/java/src/encapsulation/core/Person.java}

These members can be accessed anywhere
\lstinputlisting[language=Java, linerange={1-8,10-10,14-14,16-18}, style=codeStyle]{../codes/java/src/encapsulation/main/App.java}

\subsection{Javascript} 

All fields with the keyword \keyword{this} are public. 
All methods defined using the same keyword inside the constructor or using the prototype are public.

\lstinputlisting[linerange={3-4,12-12,16-16,22-22}, style=codeStyle]{../codes/javascript/encapsulation/person.js}

Which can be accessed anywhere

\lstinputlisting[linerange={1-1,4-4,7-7,12-12}, style=codeStyle]{../codes/javascript/encapsulation/app.js}

Actually, objects in Javascript can be updated by assigning them new fields and methods dynamically. 
This gives you the power to upgrade existing prototypes (classes) and decorate objects without the need to create more classes.
Also, as \nameword{uncle Ben} of \nameword{Spider-man} once said: ``\textit{With great power comes great responsibility}".

\lstinputlisting[linerange={1-17}, style=codeStyle]{../codes/javascript/encapsulation/decorate.js}

Here, we created two objects, but with different fields. 
Then, we can create a function which print different fields of a Person. 
Just a note: you have to verify that the member is not a function, since functions in Javascript are first class objects. 
Which means: they are a type (\keyword{function}), they are instances of \keyword{Object} and they can be treated as any variable.

\lstinputlisting[linerange={19-29}, style=codeStyle]{../codes/javascript/encapsulation/decorate.js}

\subsection{Lua}

Using tables to create objects, all members are accessible outside the class, hence public.

\lstinputlisting[language={[5.2]Lua}, linerange={1-5,7-7,11-12,14-14,17-19}, style=codeStyle]{../codes/lua/encapsulation/person.lua}

You can access them anywhere

\lstinputlisting[language={[5.2]Lua}, linerange={1-6}, style=codeStyle]{../codes/lua/encapsulation/app.lua}

\subsection{Perl}

%\lstinputlisting[language=Perl, linerange={4-4}, style=codeStyle]{../codes/perl/person.pl}

\subsection{PHP}

The default visibility mode in PHP is public.
A function defined without a visibility modifier or a variable defined using \keyword{var} are public by default. 
It is a good practice to prefix class members with a visibility modifier, since the inverse is just used to keep compatibility with versions before 5.1.3.

\lstinputlisting[language=PHP, linerange={2-5,11-11,15-15,17-17,24-24,31-31}, style=codeStyle]{../codes/php/encapsulation/person.php}

The member with public visibility mode can be accessed anywhere.

\lstinputlisting[language=PHP, linerange={3-3,6-6,8-9,17-17}, style=codeStyle]{../codes/php/encapsulation/app.php}

\subsection{Python}

All class members are public by default; it is the only visibility mode in Python. 

\lstinputlisting[language=Python, linerange={4-4, 8-8, 12-12,15-15,19-19}, style=codeStyle]{../codes/python/encapsulation/person.py}

The members can be accessed anywhere
\lstinputlisting[language=Python, linerange={4-7, 9-9, 13-13}, style=codeStyle]{../codes/python/encapsulation/app.py}

\subsection{Ruby}

By default methods are public except for \keyword{initialize} method and the global methods defined under the object class which are private always. 
If desired, you can use the keyword \keyword{public} in a line and all methods defined after it are public. 
Fields are not public unless they are constants. 
To access them like public in other languages, you have to define an accessor methods (the fields have to be properties).
In Ruby, public getters and setters are called \nameword{attribute readers} and \nameword{attribute writers}.

\lstinputlisting[language=Ruby, linerange={1-1,5-5,9-9,13-13,15-15,17-17,22-22,34-35,39-39,46-46}, style=codeStyle]{../codes/ruby/encapsulation/person.rb}

The field can be accessed for read and write. 
Actually, the field is accessed via a getter and a setter which are public by default (because they are methods).

\lstinputlisting[language=Ruby, linerange={6-9,14-14,20-20}, style=codeStyle]{../codes/ruby/encapsulation/app.rb}


\section{Protected members}

\subsection{C++}

Protected members are defined inside the class header using the modifier \keyword{protected}. 
Every member coming after that modifier is considered as protected.

\lstinputlisting[language=C++, linerange={6-7,18-19,25-25}, style=codeStyle]{../codes/cpp/encapsulation/person.h}

These members can be accessed only from the class itself or its subclasses

\lstinputlisting[language=C++, linerange={1-5,8-8}, style=codeStyle]{../codes/cpp/encapsulation/student.cpp}

They cannot be accessed elsewhere

\lstinputlisting[language=C++, linerange={10-12,16-16,27-28}, style=codeStyle]{../codes/cpp/encapsulation/app.cpp}

\subsection{Java}

Protected members are prefixed each by the keyword \keyword{protected}. 
A protected member is visible inside the class and its subclass, and also to other classes in the same package. 
There is no difference between visibility modes of fields and those of methods; they are the same.

\lstinputlisting[language=Java, linerange={1-3,7-7,34-34}, style=codeStyle]{../codes/java/src/encapsulation/core/Person.java}

The field can be accessed from a subclass (which is not necessarily in the same package)

\lstinputlisting[language=Java, linerange={1-7,11-13}, style=codeStyle]{../codes/java/src/encapsulation/core/Student.java}

It can be accessed from classes of the same package

\lstinputlisting[language=Java, linerange={1-7,10-12}, style=codeStyle]{../codes/java/src/encapsulation/core/App2.java}

And cannot be accessed from a class outside the package and not inheriting from their containing class.

\lstinputlisting[language=Java, linerange={1-8,13-13,16-18}, style=codeStyle]{../codes/java/src/encapsulation/main/App.java}

It is also important to point out that protected members can be accessed from another object of the same class 

\lstinputlisting[language=Java, linerange={3-3,7-7,29-29,31-34}, style=codeStyle]{../codes/java/src/encapsulation/core/Person.java}

\subsection{Javascript} 

There is no protected members in Javascript. 
You can find some hacks on the web, but they can be expensive in term of memory and processing power.
To emulate such mechanism, you have to know the caller object 
If you insist on having protected and private members, some libraries can be helpful such as \nameword{mozart}\footnote{mozart: \url{https://github.com/philipwalton/mozart}}.

% https://philipwalton.com/articles/implementing-private-and-protected-members-in-javascript/
% https://philipwalton.com/articles/implementing-private-and-protected-members-in-javascript/

\subsection{Lua}

There is no protected members in Lua, but you can use a naming convention to specify them.

\subsection{Perl}

%\lstinputlisting[language=Perl, linerange={4-4}, style=codeStyle]{../codes/perl/person.pl}

\subsection{PHP}

Protected members are prefixed, each, with the keyword \keyword{protected}.

\lstinputlisting[language=PHP, linerange={2-2,6-6,31-31}, style=codeStyle]{../codes/php/encapsulation/person.php}

They can be accessed from the class itself or its subclasses

\lstinputlisting[language=PHP, linerange={5-9,13-15}, style=codeStyle]{../codes/php/encapsulation/student.php}

They cannot be accessed elsewhere

\lstinputlisting[language=PHP, linerange={3-3,6-6,15-15}, style=codeStyle]{../codes/php/encapsulation/app.php}

An object can access a protected member of another of the same class

\lstinputlisting[language=PHP, linerange={2-2,26-26,28-31}, style=codeStyle]{../codes/php/encapsulation/person.php}

\subsection{Python}

In Python, all class members are publicly visible. 
But, Python community use coding conversions to tell developers about a field's visibility. 
Some developers use underscore \keyword{\_} before the class member to signal that it is protected. 
However, looking to this convension's definition in Python's docs: "\textit{a name prefixed with an underscore should be treated as a non-public part of the API. It should be considered an implementation detail and subject to change without notice.}", this suggests that it is a private member convention.
But, since there is another convention for private members (double underscore), we can view one underscore as protected.

\lstinputlisting[language=Python, linerange={4-5,8-8,11-11}, style=codeStyle]{../codes/python/encapsulation/person.py}

It can be accessed from subclasses

\lstinputlisting[language=Python, linerange={4-10}, style=codeStyle]{../codes/python/encapsulation/student.py}

Or, from any class, module or piece of code 

\lstinputlisting[language=Python, linerange={4-7,17-17}, style=codeStyle]{../codes/python/encapsulation/app.py}

The idea is to tell developers that this class member is protected and it can be changed in the future, not to enforce the visibility on them. 
If they want to access it directly, its their choice.

\subsection{Ruby}

All fields are protected by default and there is no other visibility mode. 
Methods are public by default, but can be defined as protected using either \keyword{private} or \keyword{protected}. 

\lstinputlisting[language=Ruby, linerange={2-2,7-8,10-13,16-16,25-33,47-47}, style=codeStyle]{../codes/ruby/encapsulation/person.rb}

The methods defined using \keyword{private} or \keyword{protected} can both be accessed from sub-classes.

\lstinputlisting[language=Ruby, linerange={3-4,13-19}, style=codeStyle]{../codes/ruby/encapsulation/student.rb}

The difference is that those with \keyword{private} cannot be accessed from another object even if it is of the same class. 
Those with \keyword{protected} can be accessed from the an object of the same class.

\lstinputlisting[language=Ruby, linerange={2-2,42-47}, style=codeStyle]{../codes/ruby/encapsulation/person.rb}

The fields and the protected methods cannot be accessed outside the class and its sub-classes

\lstinputlisting[language=Ruby, linerange={6-6,10-11,17-18}, style=codeStyle]{../codes/ruby/encapsulation/app.rb}

\section{Private members}

\subsection{C++}

Private members are defined inside the class header using the modifier \keyword{private}. 
Every member coming after that modifier is considered as private.

\lstinputlisting[language=C++, linerange={6-7,21-25}, style=codeStyle]{../codes/cpp/encapsulation/person.h}

These members can be accessed only from the class itself and not its subclasses

\lstinputlisting[language=C++, linerange={3-4,7-8}, style=codeStyle]{../codes/cpp/encapsulation/student.cpp}

Also, an object can access another object's members if they are of the same class whatever their visibility is.

\lstinputlisting[language=C++, linerange={23-27}, style=codeStyle]{../codes/cpp/encapsulation/person.cpp}

\subsection{Java}

Private members are prefixed each by the keyword \keyword{private}. 
A private member (field or method) is visible only inside the class. 

\lstinputlisting[language=Java, linerange={1-3,7-7,34-34}, style=codeStyle]{../codes/java/src/encapsulation/core/Person.java}

It cannot be accessed from a subclass

\lstinputlisting[language=Java, linerange={3-3,5-6,10-13}, style=codeStyle]{../codes/java/src/encapsulation/core/Student.java}

And sure cannot be accessed from another class

\lstinputlisting[language=Java, linerange={5-8,12-12,16-18}, style=codeStyle]{../codes/java/src/encapsulation/main/App.java}

It is also important to point out that private members can be accessed from another object of the same class 

\lstinputlisting[language=Java, linerange={3-3,7-7,29-30,32-34}, style=codeStyle]{../codes/java/src/encapsulation/core/Person.java}

\subsection{Javascript} 

There is a convention to use underscore \keyword{\_} as a mean to signal a class member as private. 
But the member still accessible as public. 
Another way is to use closures (the combination of a function and the lexical environment within which that function was declared), by defining a field inside the constructor using the keyword \keyword{var} or \keyword{let}.
But, any method using this variable must be defined inside the constructor.
This means each time you create a new instance (object), a new function will be created for this object. 

\lstinputlisting[linerange={1-3,5-14}, style=codeStyle]{../codes/javascript/encapsulation/person.js}

The private member defined by convention can be accessed anywhere. 
In contrary, the member defined with closures cannot be accessed.

\lstinputlisting[linerange={1-1,4-4,8-9}, style=codeStyle]{../codes/javascript/encapsulation/app.js}

\subsection{Lua}

Using closures, you can create internal fields inside the constructor of an object.
The functions which access this field must be defined inside the constructor.

\lstinputlisting[language={[5.2]Lua}, linerange={1-6,8-12,19-19}, style=codeStyle]{../codes/lua/encapsulation/person.lua}

You cannot access it outside the class. 
But, you can create a new public field dynamically, but it will not replace the internal one.

\lstinputlisting[language={[5.2]Lua}, linerange={1-3,7-8}, style=codeStyle]{../codes/lua/encapsulation/app.lua}

\subsection{Perl}

%\lstinputlisting[language=Perl, linerange={4-4}, style=codeStyle]{../codes/perl/person.pl}

\subsection{PHP}

Private members are prefixed, each, with the keyword \keyword{private}.

\lstinputlisting[language=PHP, linerange={2-2,7-7,31-31}, style=codeStyle]{../codes/php/encapsulation/person.php}

They can be accessed only from the class itself and not its subclasses

\lstinputlisting[language=PHP, linerange={5-8,12-15}, style=codeStyle]{../codes/php/encapsulation/student.php}

They cannot be accessed elsewhere

\lstinputlisting[language=PHP, linerange={3-3,6-6,14-14}, style=codeStyle]{../codes/php/encapsulation/app.php}

An object can access a protected member of another of the same class

\lstinputlisting[language=PHP, linerange={2-2,26-27,29-31}, style=codeStyle]{../codes/php/encapsulation/person.php}

\subsection{Python}

As said before: all members are public (A remainder so you don't think otherwise).
But, there is a mechanism used to avoid name clashes of names with names defined by subclasses, called \nameword{name mangling}.
When a field is prefixed by a double underscore \keyword{\_\_}, its name will be changed to \textbf{\_classname\_\_membername}.

\lstinputlisting[language=Python, linerange={4-8,10-10}, style=codeStyle]{../codes/python/encapsulation/person.py}

It can be accessed from subclasses using the new mangled name

\lstinputlisting[language=Python, linerange={4-9,11-12}, style=codeStyle]{../codes/python/encapsulation/student.py}

Or, from any class, module or piece of code. 
Trying to read the field as it is defined in the class will raise an error since it does not exist with that name anymore.
While trying to assign a value to the field will work, because you are actually creating a new field of the object dynamically.

\lstinputlisting[language=Python, linerange={4-7,14-16}, style=codeStyle]{../codes/python/encapsulation/app.py}

\subsection{Ruby}

There are no private members in Ruby, which are visible just inside their class. 
Even if you try to limit access of a field to read-only, it can be accessed from sub-classes. 
This is because the field itself is protected and \keyword{attr\_reader} creates a getter for this field. 

\lstinputlisting[language=Ruby, linerange={2-2,7-8,10-11,16-16,47-47}, style=codeStyle]{../codes/ruby/encapsulation/person.rb}

\lstinputlisting[language=Ruby, linerange={3-3,5-6,9-9,19-19}, style=codeStyle]{../codes/ruby/encapsulation/student.rb}

\section{Other visibility modes}

\subsection{C++}

public, protected and private are the only visibility modes applied to class members. 
But, a class can specify an external function of another class to be able to access its members whatever their visibility mode is. 
This is known as \nameword{friend function} and \nameword{friend class} respectively. 
They can be specified using the keyword \keyword{friend} before each. 

\lstinputlisting[language=C++, linerange={6-11,18-19,21-22,25-25}, style=codeStyle]{../codes/cpp/encapsulation/person.h}

The new class can access all fields 

\lstinputlisting[language=C++, linerange={7-14}, style=codeStyle]{../codes/cpp/encapsulation/frnd.h}

The same thing for the function

\lstinputlisting[language=C++, linerange={5-8}, style=codeStyle]{../codes/cpp/encapsulation/app.cpp}

There are some notes about friendship:
\begin{itemize}
	\item It is not transitive: a friend of a friend is not a friend.
	\item It can not be inherited: subclasses of a friend class are not friends.
\end{itemize}

\subsection{Java}

Another visibility mode is \nameword{package visibility} where the members of a class are only accessed from classes of the same package. 
If you don't prefix the member by any of the three visibility modes, it means it is a package member.

\lstinputlisting[language=Java, linerange={1-3,6-6,34-34}, style=codeStyle]{../codes/java/src/encapsulation/core/Person.java}

It can be accessed from classes of the same package

\lstinputlisting[language=Java, linerange={1-6,8-8,10-12}, style=codeStyle]{../codes/java/src/encapsulation/core/App2.java}

But cannot be accessed outside the package

\lstinputlisting[language=Java, linerange={1-8,11-11,16-18}, style=codeStyle]{../codes/java/src/encapsulation/main/App.java}

%\subsection{Javascript} 
%
%\lstinputlisting[linerange={1-1,5-5}, style=codeStyle]{../codes/javascript/person2.js}
%
%\lstinputlisting[linerange={1-1,15-15}, style=codeStyle]{../codes/javascript/person.js}
%
%
%\subsection{Lua}
%
%\lstinputlisting[language={[5.2]Lua}, linerange={1-2}, style=codeStyle]{../codes/lua/person.lua}
%
%\subsection{Perl}
%
%\lstinputlisting[language=Perl, linerange={4-4}, style=codeStyle]{../codes/perl/person.pl}
%
%\subsection{PHP}
%
%\lstinputlisting[language=PHP, linerange={2-2,27-27}, style=codeStyle]{../codes/php/person.php}
%
%\subsection{Python}
%
%\lstinputlisting[language=Python, linerange={4-4}, style=codeStyle]{../codes/python/person.py}
%
%\subsection{Ruby}
%
%\lstinputlisting[language=Ruby, linerange={3-3,19-19}, style=codeStyle]{../codes/ruby/person.rb}


%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================