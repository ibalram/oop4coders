%=====================================================================
\ifx\wholebook\relax\else
	\documentclass{KodeBook}
	\input{calls}
	\begin{document}
	\chapter{Class and Object}
\fi
%=====================================================================

\begin{introduction}
	Abstraction is the first pillar of OOP. 
	From a perception of an entity in a system or a context, we focus on certain aspects and ignore unnecessary ones.
	This entity is represented by a class or a prototype, with some attributes and methods.
	In this chapter, we will show how a class  or prototype  is implemented in each language.
\end{introduction}

\section{Class declaration}

Class definition in the following examples is self explanatory. 
We will explain prototype-based implementations though.

\subsection{C++}

\lstinputlisting[language=C++, linerange={4-5,34-34}, style=codeStyle]{../codes/cpp/person0.cpp}

\subsection{Java}

\lstinputlisting[language=Java, linerange={1-1,40-40}, style=codeStyle]{../codes/java/src/Person.java}

\subsection{Javascript}

There are no classes in javascript, a function can be used to simulate a class. 

\lstinputlisting[linerange={1-1,5-5}, style=codeStyle]{../codes/javascript/person2.js}

Since ES6, the \keyword{class} keyword has been introduced, but it still a syntactical sugar over the existing prototype-based classes.

\lstinputlisting[linerange={1-1,15-15}, style=codeStyle]{../codes/javascript/person.js}


\subsection{Lua}

There is class concept in Lua, but using its meta-programming we can create objects. 
There are many ways to do this, one famous is to  use meta-tables.
The \keyword{\_\_index} is used as fail-safe mechanism when it fails to lookup something in the table.

\lstinputlisting[language={[5.2]Lua}, linerange={1-2}, style=codeStyle]{../codes/lua/person.lua}

\subsection{Perl}

A perl class is simply a package which ends with \keyword{1;} 
If you want to create many package inside one file, you can put their definitions inside curly braces \keyword{\{\}}.

\lstinputlisting[language=Perl, linerange={4-4}, style=codeStyle]{../codes/perl/person.pl}

\subsection{PHP}

\lstinputlisting[language=PHP, linerange={2-2,27-27}, style=codeStyle]{../codes/php/person.php}

\subsection{Python}

\lstinputlisting[language=Python, linerange={4-4}, style=codeStyle]{../codes/python/person.py}

\subsection{Ruby}

\lstinputlisting[language=Ruby, linerange={3-3,19-19}, style=codeStyle]{../codes/ruby/person.rb}


\section{Constructors and destructors}

A constructor is a special function which is responsible for preparing the object to be created. 
The preparation, mostly, is concerned by initializing variables or calling some functions.

Once an object is deleted or out of scope, it is no longer needed. 
The destructor is a function which is called before deleting an object.
It can be used to free external resources used by the object before it is terminated.

\subsection{C++}

The constructor in C++ takes the same name as the class without a return type;
It can have arguments or not.
As for the destructor, it has the same name as the class prefixed by a tilde \keyword{\char`\~}.

\lstinputlisting[language=C++, linerange={4-19,34-34}, style=codeStyle]{../codes/cpp/person0.cpp}

To create an object in C++, you can create:
\begin{itemize}
	\item an automatically destroyed object when it goes out of scope, or
	\item a dynamically created object of which the address is binded to a pointer
\end{itemize}

\lstinputlisting[language=C++, linerange={40-41}, style=codeStyle]{../codes/cpp/person0.cpp}

To free the allocated object memory, in the second case, you can call \keyword{delete}. 
If the pointer you are deleting is zero, nothing will happen. 
Deleting a pointer twice will cause problems; This is why it is recommended to set is to zero right after you delete it.

\lstinputlisting[language=C++, linerange={48-48}, style=codeStyle]{../codes/cpp/person0.cpp}

\subsection{Java}

The constructor, in Java, is a function with the class name without a return type.
There is no destructor in Java, because the objects are heap allocated and heap allocated. 
Finalizers are like destructors in purpose: close files, sockets, etc. 
But, they are not called immediately after the object is freed. 
When the garbage collector collects an object with a finalizer, it enqueue it to be finalized. 
But, there is no guarantee that the finalyzer will ever be called; The application can exit without waiting the object to be finalyzed. 

\lstinputlisting[language=Java, linerange={1-1,5-17,40-40}, style=codeStyle]{../codes/java/src/Person.java}

To create a new object, use the keyword \keyword{new}.

\lstinputlisting[language=Java, linerange={28-28}, style=codeStyle]{../codes/java/src/Person.java}

To fasten the destruction of an object, you can assign \keyword{null} to all variables referencing it.

\lstinputlisting[language=Java, linerange={36-36}, style=codeStyle]{../codes/java/src/Person.java}

\subsection{Javascript}


In ES6, the constructor is a function defined using the keyword \keyword{constructor}.
There is no destructor function.

\lstinputlisting[linerange={1-6,15-15}, style=codeStyle]{../codes/javascript/person.js}

Actually, a function can be used to define a prototype (class) and it is in the same time a constructor.

\lstinputlisting[linerange={1-5}, style=codeStyle]{../codes/javascript/person2.js}

To create a new object, you use the keyword \keyword{new}

\lstinputlisting[linerange={19-19}, style=codeStyle]{../codes/javascript/person.js}

\subsection{Lua}

In class declaration, we declared a class as a meta-table. 
The constructor is a function which has a name chosen by the programmer, usually \keyword{new} or \keyword{create}. 
This function must return an object to which you have to set a meta-table (our class) using the method \keyword{setmetatable}

\lstinputlisting[language={[5.2]Lua}, linerange={4-7}, style=codeStyle]{../codes/lua/person.lua}

Then to create a new object, we simply call that function.

\lstinputlisting[language={[5.2]Lua}, linerange={19-19}, style=codeStyle]{../codes/lua/person.lua}

Another fancy way to create a constructor is by using the meta-method \keyword{\_\_call} which allows us to call our meta-table as a function. 

\lstinputlisting[language={[5.2]Lua}, linerange={4-9}, style=codeStyle]{../codes/lua/person2.lua}

Then, we create a new object as follows

\lstinputlisting[language={[5.2]Lua}, linerange={21-21}, style=codeStyle]{../codes/lua/person2.lua}

\subsection{Perl}

In Perl, the constructor is a subroutine called \keyword{new}. 
The arguments are shifted from the global variable \keyword{@\_} where the first one is the class itself.
You have to create a hash and marking it with a package (class = package) name using \keyword{bless}.

When the last reference to an object goes away, the object is destroyed.
In this case, Perl will call the method \keyword{DESTROY} if it is defined.

\lstinputlisting[language=Perl, linerange={3-23,34-34}, style=codeStyle]{../codes/perl/person.pl}

To create a new object, either you use the keyword \keyword{new} or use the arrow function.  
If you use the second method, you can call your constructor whatever you want; But, by convention it is \keyword{new}.

\lstinputlisting[language=Perl, linerange={36-37}, style=codeStyle]{../codes/perl/person.pl}

To delete a reference, you use \keyword{undef} which will trigger the destructor.

\lstinputlisting[language=Perl, linerange={44-44}, style=codeStyle]{../codes/perl/person.pl}

\subsection{PHP}

The constructor is a function called \keyword{\_\_construct} and the destructor is a function called \keyword{\_\_destruct}.

\lstinputlisting[language=PHP, linerange={2-2,8-17,27-27}, style=codeStyle]{../codes/php/person.php}

To create an instance of the class, the keyword \keyword{new} is used.

\lstinputlisting[language=PHP, linerange={29-29}, style=codeStyle]{../codes/php/person.php}

To delete a reference, the keyword \keyword{unset} is used.

\lstinputlisting[language=PHP, linerange={37-37}, style=codeStyle]{../codes/php/person.php}

\subsection{Python}

The constructor is a function called \keyword{\_\_init\_\_} and the destructor is a function called \keyword{\_\_del\_\_}.

\lstinputlisting[language=Python, linerange={4-4,8-15}, style=codeStyle]{../codes/python/person.py}

To create an object, we call the class as a function

\lstinputlisting[language=Python, linerange={24-24}, style=codeStyle]{../codes/python/person.py}

To delete a reference, the keyword \keyword{del} is used.

\lstinputlisting[language=Python, linerange={32-32}, style=codeStyle]{../codes/python/person.py}


\subsection{Ruby}

The constructor is a function called \keyword{initialize}.
Ruby does not have a destructor, but it has a finalizer.
To bind the object with a finalizing function, you have to call \keyword{ObjectSpace.define\_finalizer} in the constructor.
The finalizer, like Java, can never be called.

\lstinputlisting[language=Ruby, linerange={3-17,25-25}, style=codeStyle]{../codes/ruby/person.rb}

To create a new object from our class, we call its function \keyword{new}.

\lstinputlisting[language=Ruby, linerange={27-27}, style=codeStyle]{../codes/ruby/person.rb}

To free a reference from an object, you can assign it the \keyword{nil} value.

\lstinputlisting[language=Ruby, linerange={35-35}, style=codeStyle]{../codes/ruby/person.rb}

\section{Members}

There are three types of members: 
\begin{itemize}
	\item Field: They are state variables. For example: a person has a name, birth year, etc.
	\item Methods: Procedures which define the behavior of the object. For example: a person can talk, walk, etc.
	\item Properties: They are something between a field and a method. The read/write syntax is similar to fields' but it is translated into getters/setters methods.
\end{itemize}

A member can be accessed as: 
\begin{itemize}
	\item Class member: It is shared between all the instances of this class.
	\item Object member: The member is specific to the instance (object)
\end{itemize}

For properties, lets say: we have a class Rectangle which is composed of height and width. 
We want to keep the width, always, bigger or equal to the height.
For the sake of the example, suppose when we want to get the height we add 1 and when we want to get the width we add 2.
Also, suppose only the width has a setter and the height will receive its value based on the previous width and its setter's value.
We assign the width twice: 50 and 20. 
Then, we use an internal function \textbf{info} which shows the state of the two fields. 
Finally, we use getters over the two fields and print the recovered values. 
The result in the languages which support properties, or has a way to emulate them, should be as follows
\begin{lstlisting}[style=shellStyle]
Width: 50, Height: 20
w: 52, h: 21
\end{lstlisting}  

\subsection{C++}

Fields are defined by type and name inside the class header. 
Static fields are defined using the keyword \keyword{static}.

\lstinputlisting[language=C++, linerange={31-33}, style=codeStyle]{../codes/cpp/person0.cpp}

Non constant class (static) fields must be initialized outside the header and not inside it. 

\lstinputlisting[language=C++, linerange={36-36}, style=codeStyle]{../codes/cpp/person0.cpp} 

Methods can be defined inside the class header as in this example.
Static methods must be defined using the keyword \keyword{static}. 

\lstinputlisting[language=C++, linerange={20-27}, style=codeStyle]{../codes/cpp/person0.cpp}

To call a static method, you should use class name. 
As for the object method, if the reference is a pointer use arrow annotation.

\lstinputlisting[language=C++, linerange={43-45}, style=codeStyle]{../codes/cpp/person0.cpp}

There are no properties in C++, but they can be emulated by overriding assigning operator.

\subsection{Java}

Fields are defined by access modifier (See Encapsulation chapter), type and name. 
Class (static) fields are defined using the keyword \keyword{static}.
All fields must be defined inside the class block; They can be initialized without needing a constructor. 
In fact, they are automatically initialized: integers to 0, objects no Null, etc. 

\lstinputlisting[language=Java, linerange={2-4}, style=codeStyle]{../codes/java/src/Person.java}

Methods are defined inside the class block where static ones are distinguished by the keyword \keyword{static}.

\lstinputlisting[language=Java, linerange={18-25}, style=codeStyle]{../codes/java/src/Person.java}

Static methods are called using the class name; But, also, they can be called from the instance. 

\lstinputlisting[language=Java, linerange={31-33}, style=codeStyle]{../codes/java/src/Person.java}

There are no properties in Java, you have to define your getters/setters and use them as methods. 
As far as we know, there is no mechanism to emulate their functionality either.


\subsection{Javascript}

The fields are defined inside the class body (either ES6 class or function) using the keyword \keyword{this}. 
You can define them using two methods (they are the same), as shown in the example.

\lstinputlisting[linerange={3-4}, style=codeStyle]{../codes/javascript/person.js}

As for static fields, you can use the pattern <class name>.<field> to access it. 
The field must be initialized outside the class definition.

\lstinputlisting[linerange={17-17}, style=codeStyle]{../codes/javascript/person.js}

Methods are defined inside the class definition in ES6. 
Also, static methods are preceded by the keyword \keyword{static}. 

\lstinputlisting[linerange={1-1,8-15}, style=codeStyle]{../codes/javascript/person.js}

If the class is defined using a function (which is the real definition in javascript), you can define functions inside the constructor using the keyword \keyword{this}. 
Also, you can define them outside the constructor by assigning a function to the class's prototype.

\lstinputlisting[linerange={9-15}, style=codeStyle]{../codes/javascript/person2.js}

Properties can be defined using \keyword{Object.defineProperties} and the keywords \keyword{get} and \keyword{set}.

\lstinputlisting[linerange={9-11,13-14,22-25,27-35}, style=codeStyle]{../codes/javascript/property.js}

\subsection{Lua}

The fields are defined inside the table which will be our object. 
In our example, a table is created inside the constructor then the class table is set to be its meta-table. 
To define a static field, it can be assigned to the meta-table (our class).

\lstinputlisting[language={[5.2]Lua}, linerange={4-9}, style=codeStyle]{../codes/lua/person.lua}

To define dynamic methods, there are two ways where the colon (\keyword{:}) will add \keyword{self} implicitly.
\begin{lstlisting}[style=codeStyle, language={[5.2]Lua}]
function ClassName.method1(self)
end
function ClassName:method2()
end
\end{lstlisting} 

As for static methods, they are defined as \textit{method1} without \keyword{self} keyword.

\lstinputlisting[language={[5.2]Lua}, linerange={11-17}, style=codeStyle]{../codes/lua/person.lua}

To call the methods, there are two ways for dynamic methods.

\lstinputlisting[language={[5.2]Lua}, linerange={22-24}, style=codeStyle]{../codes/lua/person.lua}

Properties can be defined by using the meta-methods \keyword{\_\_index} and \keyword{\_\_newindex}.
When the interpreter can not find a field, it calls the \keyword{\_\_index} meta-method. 
It has \keyword{self} and a key as arguments, and can be used to define getters in our case. 
You have to verify if the key exists already and return the member, otherwise your methods will not be known by the interpreter. 
\keyword{\_\_newindex} meta-method is used for table update and can be used as a setter. 

\lstinputlisting[language={[5.2]Lua}, linerange={1-15,22-24,33-38}, style=codeStyle]{../codes/lua/property.lua}

\subsection{Perl}

Object fields are defined in the hash which will be returned by the \keyword{new} subroutine as the new object. 

\lstinputlisting[language=Perl, linerange={10-13}, style=codeStyle]{../codes/perl/person.pl}

Class (static) fields are defined outside the new subroutine as variable scoped at the file level using \keyword{my} keyword.
Or you can define a package level variable using the keyword \keyword{our}.

\lstinputlisting[language=Perl, linerange={6-6}, style=codeStyle]{../codes/perl/person.pl}

There is no difference between dynamic and static methods. 
If the method is called as an object one, the object will be passed as the first argument. 
If it is called as a class one, the class name will be passed as the first argument. 
The implementation of the method will decide its access type.

\lstinputlisting[language=Perl, linerange={25-32}, style=codeStyle]{../codes/perl/person.pl}

As said, the difference between dynamic and static methods is in how they are called. 

\lstinputlisting[language=Perl, linerange={39-41}, style=codeStyle]{../codes/perl/person.pl}

Properties in Perl do not follow the definition we gave in this section; 
Sure we can define setters/getters, but they do not behave as attributes. 
A subroutine which has two arguments (the object and the value) is a setter.
If there is just one, then it is a getter. 

\lstinputlisting[language=Perl, linerange={3-3,14-17,25-33,40-46}, style=codeStyle]{../codes/perl/property.pl}

\subsection{PHP}

The fields are defined by access, type and name.
In PHP, there are called properties; But, we rather call them fields to differentiate them from the properties we defined earlier.
A static field is defined by the keyword \keyword{static}.

\lstinputlisting[language=PHP, linerange={2-7,27-27}, style=codeStyle]{../codes/php/person.php}

There are no difference between static and dynamic functions in header syntax. 
The difference is in implementation: the static one can access just static fields by using the keyword \keyword{self} instead of \keyword{this}.

\lstinputlisting[language=PHP, linerange={2-2,19-25,27-27}, style=codeStyle]{../codes/php/person.php}

The call is different between dynamic and static functions.

\lstinputlisting[language=PHP, linerange={32-34}, style=codeStyle]{../codes/php/person.php}

Properties getters/setters can be defined using php magic methods \keyword{\_\_get} and \keyword{\_\_set}.
It is considered bad practice though, and the alternative is to define getters and setters specified for each property.

\lstinputlisting[language=PHP, linerange={2-2,11-12,21-37}, style=codeStyle]{../codes/php/property.php}

\subsection{Python}

Static fields are defined inside the class block, while dynamic fields are defined inside the constructor using the keyword \keyword{self}. 
In pure Python, the dynamic fields of an object (instance) are stored in a dictionary \keyword{self.\_\_dict\_\_}.
The static field is accessed by the class name, not by \keyword{self}.
Also, static fields are stored in other dictionary bounded to the class, not the instance.

\lstinputlisting[language=Python, linerange={4-11}, style=codeStyle]{../codes/python/person.py}

Methods are defined using the keyword \keyword{def} inside the class block. 
There is no difference between static and dynamic methods in term of header syntax. 
But in Python 2.6+, you can use the decorator \keyword{\@staticmethod} to mark a static method. 

\lstinputlisting[language=Python, linerange={4-4,17-22}, style=codeStyle]{../codes/python/person.py}

The dynamic methods are accessed via the instance while the static ones are accessed using the class name.

\lstinputlisting[language=Python, linerange={27-29}, style=codeStyle]{../codes/python/person.py}

Properties can be defined using the new style classes (object as superclass) for Python 2.2+.
Starting from Python 2.6, there are decorators to define setters and getters.
In the example, the implementation is omitted.

\lstinputlisting[language=Python, linerange={4-4,13-14,16-18,20-22, 28-33}, style=codeStyle]{../codes/python/property.py}

\subsection{Ruby}

Static fields are defined inside the class block using \keyword{\@\@}, while dynamic fields are defined inside the constructor or the class block using the keyword \keyword{\@}. 

\lstinputlisting[language=Ruby, linerange={3-11,25-25}, style=codeStyle]{../codes/ruby/person.rb}

Methods are defined using the keyword \keyword{def} and delimited by the keyword \textbf{end}. 
Static methods always begin with the keyword \keyword{self}.
Also, methods without arguments do not need round brackets \keyword{()}.

\lstinputlisting[language=Ruby, linerange={3-3,18-25}, style=codeStyle]{../codes/ruby/person.rb}

We call dynamic methods using the instance name and static ones using the class name. 
Round brackets can be omitted if no argument is expected.

\lstinputlisting[language=Ruby, linerange={30-32}, style=codeStyle]{../codes/ruby/person.rb}

Properties can be defined by a field using a no-arguments method as a getter and another with the template \textbf{<prperty name> = (value)} as a setter.

\lstinputlisting[language=Ruby, linerange={3-3,9-17,24-24,30-36}, style=codeStyle]{../codes/ruby/property.rb}

Also, there are automatically implemented getters/setters in Ruby

\begin{lstlisting}[style=codeStyle, language=Ruby]
class Rectangle
	attr_accessor :width # read/write
	attr_reader :height # read only
	attr_writer :bar # write only
end 
\end{lstlisting} 

\section{Object methods}

These are methods inherited from the Object class, or as called by some languages: magic methods.
In here, we present the methods which most programming languages agree on:
\begin{itemize}
	\item String representation: When an object is concatenated with a string, it can act as string by calling this function.
	\item Object copy: A function which enables an object to create a clone of itself.
	\item Value equality: A function which helps to decide if an object equals another based on some criteria (their fields).
	\item Object comparison: A function which is used to decide if an object is greater, equal or lesser than another.
	\item Hash code: A function which returns a hash code for the object. 
\end{itemize}

In our example, we will implement our \textbf{Person} class, and the previously presented methods as follows:
\begin{itemize}
	\item String representation: The function must return a string containing the name and the year of birth.
	\item Object copy: The function must return a new object with the same name but with plus one year to the current birth year.
	\item Value equality: The function returns true if the objects have the same value for the field called \textbf{name}.
	\item Object comparison: The comparison is made on birth years; If they are equal, then on the name.
	\item Hash code: The hash code will be based on the name (we can add the year as well, but it will be a long code). 
\end{itemize}


\subsection{C++}

In C++, there are no methods inherited from the object class because there is no universal base-class object. 
But, C++ support operations overloading which can replace base-class methods.
To overload an operation for a class based on its fields, you have to define these operations as friend operations to the class. 
this will allow them to access private members. 

\lstinputlisting[language=C++, linerange={4-5, 18-21,24-24}, style=codeStyle]{../codes/cpp/obj_meth.cpp}

\subsubsection{String representation}

There is no \keyword{toString} in C++, where an object can be transformed to a string when it is concatenated with one. 
But, operators such as \keyword{<{}<} can be overloaded to handle an object of a class as a string.   

\lstinputlisting[language=C++, linerange={26-28}, style=codeStyle]{../codes/cpp/obj_meth.cpp}

Then, you can call it as

\lstinputlisting[language=C++, linerange={41-41,44-44}, style=codeStyle]{../codes/cpp/obj_meth.cpp}

\subsubsection{Object copy}

You can just define a cloning function for the class and use it.

\subsubsection{Value equality}
 
You can overload the operator \keyword{==} to test the equality between two objects of the same class.  

\lstinputlisting[language=C++, linerange={30-32}, style=codeStyle]{../codes/cpp/obj_meth.cpp}

\subsubsection{Object comparison}

You can overload the operators \keyword{>}, \keyword{<}, \keyword{>=} and \keyword{<=} to compare two objects of the same class.  
\keyword{std::string} class has its own \keyword{compare} method.

\lstinputlisting[language=C++, linerange={34-37}, style=codeStyle]{../codes/cpp/obj_meth.cpp}

\subsubsection{Hash code}

You can define a hashcode function for your current class.

\subsection{Java}

In Java, every class inherit from the universal class \keyword{Object}. 
This class defines some methods by default: string representation, object copy, value equality and hashcode.
To personalize them, you can override these functions in your class.

\subsubsection{String representation}

You can override \keyword{toString} which comes from the class \keyword{Object}.   

\lstinputlisting[language=Java, linerange={24-24,34-37,63-63}, style=codeStyle]{../codes/java/src/ObjMeth.java}

When the object is concatenated with strings, this function will be called automatically to represent this object as a string.

\lstinputlisting[language=Java, linerange={7-7}, style=codeStyle]{../codes/java/src/ObjMeth.java}

\subsubsection{Object copy}

The universal class \keyword{Object} implements a function \keyword{clone()} which performs a shallow copy.
That is, if a field is an object (not primary type), it will copy the reference and not create a new instance of it. 
To perform deep copy, you have to override this function. 
But before that, you have to implement the class \keyword{Clonable} otherwise your function will throw an exception \keyword{CloneNotSupportedException}.

\lstinputlisting[language=Java, linerange={24-24,50-54,63-63}, style=codeStyle]{../codes/java/src/ObjMeth.java}

\subsubsection{Value equality}

You can override the method \keyword{equals} which takes a variable of type \keyword{Object} as argument.
This is the other object to which we want to test our current object, and it can be of any other effective type. 
So, basically, you can test your current object against any other type if you wish to.
In our example, if the other object is not of the same type as the current's, the function returns false.

\lstinputlisting[language=Java, linerange={24-24,44-48,63-63}, style=codeStyle]{../codes/java/src/ObjMeth.java}

When testing equality with non primitive variables, you have to call this function. 
If you use \keyword{==} instead, you will have a reference equality test; that is, the variables will be tested if they have the same reference or not.

\lstinputlisting[language=Java, linerange={14-15}, style=codeStyle]{../codes/java/src/ObjMeth.java}

\subsubsection{Object comparison}

Objects, by default, do not implement a comparing method. 
If you want to compare an object with another, you can implement the interface \keyword{Comparable}. 
It is very useful since a lot of other methods are based on it such as \keyword{sort} of collections.
Then, you have to implement one method which is \keyword{compareTo}. 
It takes one argument of type \keyword{Object} which is the other object to compare to, unless you use generics to specify that object's type. 
This function returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.

\lstinputlisting[language=Java, linerange={24-24,56-63}, style=codeStyle]{../codes/java/src/ObjMeth.java}

\subsubsection{Hash code}

You can override \keyword{hashCode()} method to define specialized hash code calculation to a class.
\lstinputlisting[language=Java, linerange={39-42}, style=codeStyle]{../codes/java/src/ObjMeth.java}

\subsection{Javascript}

\lstinputlisting[style=codeStyle]{../codes/javascript/person.js}

\subsection{Lua}

\lstinputlisting[language={[5.2]Lua}, style=codeStyle]{../codes/lua/objmeth.lua}

\subsection{Perl}

ToString can be customized by overriding the object's conversion operator. 

\lstinputlisting[language=Perl, style=codeStyle]{../codes/perl/objmeth.pl}

\subsection{PHP}

\lstinputlisting[language=PHP, style=codeStyle]{../codes/php/objmeth.php}

\subsection{Python}

\lstinputlisting[language=Python, style=codeStyle]{../codes/python/objmeth.py}

Comparing method \textbf{\_\_cmp\_\_} is no longer available for Python3. 
But, other comparison methods are: \textbf{\_\_lt\_\_}, \textbf{\_\_gt\_\_}, etc.

\subsection{Ruby}

To create a copy, there are two methods: \textbf{clone} and \textbf{dup}. 
\textbf{dup} creates a new copy of the object, but its original members are shared. 
Which means, if I copy an object then modify the attributes in the copy, this will affect the original.

\lstinputlisting[language=Ruby, style=codeStyle]{../codes/ruby/objmeth.rb}

The two methods (\textbf{initialize\_dup} and \textbf{initialize\_clone}) call \textbf{initialize\_copy} when they are done.


The hashCode in Ruby changes between sessions.
It means, if you execute the program and then re-execute it again, you will not have the same hashcode of an object.

%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================