%=====================================================================
\ifx\wholebook\relax\else
	\documentclass{KodeBook}
	\input{calls}
	\begin{document}
	\chapter{Class and Object}
\fi
%=====================================================================

\begin{introduction}
	Abstraction is the first pillar of OOP. 
	From a perception of an entity in a system or a context, we focus on certain aspects and ignore unnecessary ones.
	This entity is represented by a class or a prototype, with some attributes and methods.
	In this chapter, we will show how a class  or prototype  is implemented in each language.
\end{introduction}

\section{Class declaration}

Class definition in the following examples is self explanatory. 
We will explain prototype-based implementations though.

\subsection{C++}

\lstinputlisting[language=C++, linerange={4-5,34-34}, style=codeStyle]{../cpp/person0.cpp}

\subsection{Java}

\lstinputlisting[language=Java, linerange={1-1,40-40}, style=codeStyle]{../java/src/Person.java}

\subsection{Javascript}

There are no classes in javascript, a function can be used to simulate a class. 

\lstinputlisting[linerange={1-1,5-5}, style=codeStyle]{../javascript/person2.js}

Since ES6, the \textbf{class} keyword has been introduced, but it still a syntactical sugar over the existing prototype-based classes.

\lstinputlisting[linerange={1-1,15-15}, style=codeStyle]{../javascript/person.js}


\subsection{Lua}

There is class concept in Lua, but using its meta-programming we can create objects. 
There are many ways to do this, one famous is to  use meta-tables.
The \textbf{\_\_index} is used as fail-safe mechanism when it fails to lookup something in the table.

\lstinputlisting[language={[5.2]Lua}, linerange={1-2}, style=codeStyle]{../lua/person.lua}

\subsection{Perl}

A perl class is simply a package which ends with \textbf{1;} 
If you want to create many package inside one file, you can put their definitions inside curly braces \textbf{\{\}}.

\lstinputlisting[language=Perl, linerange={4-4}, style=codeStyle]{../perl/person.pl}

\subsection{PHP}

\lstinputlisting[language=PHP, linerange={2-2,27-27}, style=codeStyle]{../php/person.php}

\subsection{Python}

\lstinputlisting[language=Python, linerange={4-4}, style=codeStyle]{../python/person.py}

\subsection{Ruby}

\lstinputlisting[language=Ruby, linerange={3-3,19-19}, style=codeStyle]{../ruby/person.rb}


\section{Constructors and destructors}

A constructor is a special function which is responsible for preparing the object to be created. 
The preparation, mostly, is concerned by initializing variables or calling some functions.

Once an object is deleted or out of scope, it is no longer needed. 
The destructor is a function which is called before deleting an object.
It can be used to free external resources used by the object before it is terminated.

\subsection{C++}

The constructor in C++ takes the same name as the class without a return type;
It can have arguments or not.
As for the destructor, it has the same name as the class prefixed by a tilde \textbf{~}.

\lstinputlisting[language=C++, linerange={4-19,34-34}, style=codeStyle]{../cpp/person0.cpp}

To create an object in C++, you can create:
\begin{itemize}
	\item an automatically destroyed object when it goes out of scope, or
	\item a dynamically created object of which the address is binded to a pointer
\end{itemize}

\lstinputlisting[language=C++, linerange={40-41}, style=codeStyle]{../cpp/person0.cpp}

To free the allocated object memory, in the second case, you can call \textbf{delete}. 
If the pointer you are deleting is zero, nothing will happen. 
Deleting a pointer twice will cause problems; This is why it is recommended to set is to zero right after you delete it.

\lstinputlisting[language=C++, linerange={48-48}, style=codeStyle]{../cpp/person0.cpp}

\subsection{Java}

The constructor, in Java, is a function with the class name without a return type.
There is no destructor in Java, because the objects are heap allocated and heap allocated. 
Finalizers are like destructors in purpose: close files, sockets, etc. 
But, they are not called immediately after the object is freed. 
When the garbage collector collects an object with a finalizer, it enqueue it to be finalized. 
But, there is no guarantee that the finalyzer will ever be called; The application can exit without waiting the object to be finalyzed. 

\lstinputlisting[language=Java, linerange={1-1,5-17,40-40}, style=codeStyle]{../java/src/Person.java}

To create a new object, use the keyword \textbf{new}.

\lstinputlisting[language=Java, linerange={28-28}, style=codeStyle]{../java/src/Person.java}

To fasten the destruction of an object, you can assign \textbf{null} to all variables referencing it.

\lstinputlisting[language=Java, linerange={36-36}, style=codeStyle]{../java/src/Person.java}

\subsection{Javascript}


In ES6, the constructor is a function defined using the keyword \textbf{constructor}.
There is no destructor function.

\lstinputlisting[linerange={1-6,15-15}, style=codeStyle]{../javascript/person.js}

Actually, a function can be used to define a prototype (class) and it is in the same time a constructor.

\lstinputlisting[linerange={1-5}, style=codeStyle]{../javascript/person2.js}

To create a new object, you use the keyword \textbf{new}

\lstinputlisting[linerange={19-19}, style=codeStyle]{../javascript/person.js}

\subsection{Lua}

In class declaration, we declared a class as a meta-table. 
The constructor is a function which has a name chosen by the programmer, usually \textbf{new} or \textbf{create}. 
This function must return an object to which you have to set a meta-table (our class) using the method \textbf{setmetatable}

\lstinputlisting[language={[5.2]Lua}, linerange={4-7}, style=codeStyle]{../lua/person.lua}

Then to create a new object, we simply call that function.

\lstinputlisting[language={[5.2]Lua}, linerange={19-19}, style=codeStyle]{../lua/person.lua}

Another fancy way to create a constructor is by using the meta-method \textbf{\_\_call} which allows us to call our meta-table as a function. 

\lstinputlisting[language={[5.2]Lua}, linerange={4-9}, style=codeStyle]{../lua/person2.lua}

Then, we create a new object as follows

\lstinputlisting[language={[5.2]Lua}, linerange={21-21}, style=codeStyle]{../lua/person2.lua}

\subsection{Perl}

\lstinputlisting[language=Perl, linerange={3-23,34-34}, style=codeStyle]{../perl/person.pl}

\lstinputlisting[language=Perl, linerange={36-36}, style=codeStyle]{../perl/person.pl}

\lstinputlisting[language=Perl, linerange={44-44}, style=codeStyle]{../perl/person.pl}

\subsection{PHP}

\lstinputlisting[language=PHP, linerange={2-2,8-17,27-27}, style=codeStyle]{../php/person.php}

\lstinputlisting[language=PHP, linerange={29-29}, style=codeStyle]{../php/person.php}

\lstinputlisting[language=PHP, linerange={37-37}, style=codeStyle]{../php/person.php}

for static members, we use self, for dynamic we use this

\subsection{Python}

\lstinputlisting[language=Python, linerange={4-4,8-15}, style=codeStyle]{../python/person.py}

\lstinputlisting[language=Python, linerange={24-24}, style=codeStyle]{../python/person.py}

\lstinputlisting[language=Python, linerange={32-32}, style=codeStyle]{../python/person.py}


\subsection{Ruby}

\lstinputlisting[language=Ruby, linerange={3-10,19-19}, style=codeStyle]{../ruby/person.rb}

\lstinputlisting[language=Ruby, linerange={21-21}, style=codeStyle]{../ruby/person.rb}

\lstinputlisting[language=Ruby, linerange={29-29}, style=codeStyle]{../ruby/person.rb}

\section{Members}

There are three types of members: 
\begin{itemize}
	\item Fields
	\item Methods
	\item Properties
\end{itemize}

A member can be accessed as: 
\begin{itemize}
	\item Class member: it is shared by all the instances of this class.
	\item Object member: the member is specific to the instance (object)
\end{itemize}


\subsection{C++}

fields: 
\lstinputlisting[language=C++, linerange={31-33}, style=codeStyle]{../cpp/person0.cpp}

Non constant class fields must be initialized outside the header and not inside it. 

\lstinputlisting[language=C++, linerange={36-36}, style=codeStyle]{../cpp/person0.cpp} 

Methods:
\lstinputlisting[language=C++, linerange={20-27}, style=codeStyle]{../cpp/person0.cpp}

\lstinputlisting[language=C++, linerange={43-45}, style=codeStyle]{../cpp/person0.cpp}


There are no properties in C++.

\subsection{Java}

\lstinputlisting[language=Java, linerange={2-4}, style=codeStyle]{../java/src/Person.java}

\lstinputlisting[language=Java, linerange={18-25}, style=codeStyle]{../java/src/Person.java}

There are no properties in Java.


\subsection{Javascript}

\lstinputlisting[linerange={3-4}, style=codeStyle]{../javascript/person.js}

\lstinputlisting[linerange={17-17}, style=codeStyle]{../javascript/person.js}

Methods: 

\lstinputlisting[linerange={1-1,8-15}, style=codeStyle]{../javascript/person.js}

\lstinputlisting[linerange={9-15}, style=codeStyle]{../javascript/person2.js}

getters and setters can be defined using keywords \textbf{get} and \textbf{set} in ES6.

\subsection{Lua}

\lstinputlisting[language={[5.2]Lua}, linerange={4-9}, style=codeStyle]{../lua/person.lua}

\lstinputlisting[language={[5.2]Lua}, linerange={11-17}, style=codeStyle]{../lua/person.lua}

\lstinputlisting[language={[5.2]Lua}, linerange={22-24}, style=codeStyle]{../lua/person.lua}


\subsection{Perl}

\lstinputlisting[language=Perl, linerange={10-13}, style=codeStyle]{../perl/person.pl}

\lstinputlisting[language=Perl, linerange={6-6}, style=codeStyle]{../perl/person.pl}

Methods

\lstinputlisting[language=Perl, linerange={25-32}, style=codeStyle]{../perl/person.pl}

\lstinputlisting[language=Perl, linerange={39-41}, style=codeStyle]{../perl/person.pl}

%TODO reedit
``\textit{A static method applies functionality to the class as a whole because it uses the name of the class. Therefore, functionality in static methods is applicable to all objects of the class. Generally, static methods ignore the first argument because they already know which class they are in. Therefore, constructors are static methods.}"

\subsection{PHP}

\lstinputlisting[language=PHP, linerange={2-7,27-27}, style=codeStyle]{../php/person.php}

\lstinputlisting[language=PHP, linerange={2-2,19-25,27-27}, style=codeStyle]{../php/person.php}

\lstinputlisting[language=PHP, linerange={32-34}, style=codeStyle]{../php/person.php}

\subsection{Python}

\lstinputlisting[language=Python, linerange={4-11}, style=codeStyle]{../python/person.py}

\subsection{Ruby}

\lstinputlisting[language=Ruby, linerange={3-10,19-19}, style=codeStyle]{../ruby/person.rb}

\lstinputlisting[language=Ruby, linerange={3-3,12-19}, style=codeStyle]{../ruby/person.rb}

\lstinputlisting[language=Ruby, linerange={24-26}, style=codeStyle]{../ruby/person.rb}


\section{Object methods}

\begin{itemize}
	\item String representation
	\item Object copy
	\item Value equality
	\item Object comparison
	\item Hash code
\end{itemize}


\subsection{C++}

There is no toString in C++, where an object can be transformed to a string when it is concatenated with one. 
But, operators such as \textbf{<<} can be redefined to handle an object of a class as a string. 
A condition to use such methods is to define them as friend, so they can access the class's internal elements.  

\lstinputlisting[language=C++, style=codeStyle]{../cpp/obj_meth.cpp}

\subsection{Java}

\lstinputlisting[language=Java, linerange={23-23,33-62}, style=codeStyle]{../java/src/ObjMeth.java}

\lstinputlisting[language=Java, linerange={4-17}, style=codeStyle]{../java/src/ObjMeth.java}

\subsection{Javascript}

\lstinputlisting[style=codeStyle]{../javascript/person.js}

\subsection{Lua}

\lstinputlisting[language={[5.2]Lua}, style=codeStyle]{../lua/objmeth.lua}

\subsection{Perl}

ToString can be customized by overriding the object's conversion operator. 

\lstinputlisting[language=Perl, style=codeStyle]{../perl/objmeth.pl}

\subsection{PHP}

\lstinputlisting[language=PHP, style=codeStyle]{../php/objmeth.php}

\subsection{Python}

\lstinputlisting[language=Python, style=codeStyle]{../python/objmeth.py}

Comparing method \textbf{\_\_cmp\_\_} is no longer available for Python3. 
But, other comparison methods are: \textbf{\_\_lt\_\_}, \textbf{\_\_gt\_\_}, etc.

\subsection{Ruby}

To create a copy, there are two methods: \textbf{clone} and \textbf{dup}. 
\textbf{dup} creates a new copy of the object, but its original members are shared. 
Which means, if I copy an object then modify the attributes in the copy, this will affect the original.

\lstinputlisting[language=Ruby, style=codeStyle]{../ruby/objmeth.rb}

The two methods (\textbf{initialize\_dup} and \textbf{initialize\_clone}) call \textbf{initialize\_copy} when they are done.


The hashCode in Ruby changes between sessions.
It means, if you execute the program and then re-execute it again, you will not have the same hashcode of an object.

%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================