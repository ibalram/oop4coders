%=====================================================================
\ifx\wholebook\relax\else
	\documentclass{KodeBook}
	\input{calls}
	\begin{document}
\fi
%=====================================================================

\chapter{Class and Object}

\begin{introduction}
	Abstraction is the first pillar of OOP. 
	From a perception of an entity in a system or a context, we focus on certain aspects and ignore unnecessary ones.
	This entity is represented by a class or a prototype, with some attributes and methods.
	In this chapter, we will show how a class  or prototype  is implemented in each language.
\end{introduction}

\section{Class declaration}

Class definition in the following examples is self explanatory. 
We will explain prototype-based implementations though.

\subsection{C++}

\lstinputlisting[language={[KB]C++}, linerange={4-5,34-34}, style=codeStyle]{../codes/cpp/clsobj/person0.cpp}

\subsection{Java}

\lstinputlisting[language={[KB]Java}, linerange={3-3,43-43}, style=codeStyle]{../codes/java/src/clsobj/Person.java}

\subsection{Javascript}

There are no classes in javascript, a function can be used to simulate a class. 

\lstinputlisting[language={[KB]Javascript}, linerange={1-1,5-5}, style=codeStyle]{../codes/javascript/clsobj/person2.js}

Since ES6, the \keyword{class} keyword has been introduced, but it still a syntactical sugar over the existing prototype-based classes.

\lstinputlisting[language={[KB]Javascript}, linerange={1-1,15-15}, style=codeStyle]{../codes/javascript/clsobj/person.js}


\subsection{Lua}

There is class concept in Lua, but using its meta-programming we can create objects. 
There are many ways to do this, one famous is to  use meta-tables.
The \keyword{\_\_index} is used as fail-safe mechanism when it fails to lookup something in the table.

\lstinputlisting[language={[KB]Lua}, linerange={1-2}, style=codeStyle]{../codes/lua/clsobj/person.lua}

\subsection{Perl}

A perl class is simply a package which ends with \keyword{1;} 
If you want to create many package inside one file, you can put their definitions inside curly braces \keyword{\{\}}.

\lstinputlisting[language={[KB]Perl}, linerange={4-4}, style=codeStyle]{../codes/perl/clsobj/person.pl}

\subsection{PHP}

\lstinputlisting[language={[KB]PHP}, linerange={2-2,27-27}, style=codeStyle]{../codes/php/clsobj/person.php}

\subsection{Python}

\lstinputlisting[language={[KB]Python}, linerange={4-4}, style=codeStyle]{../codes/python/clsobj/person.py}

\subsection{Ruby}

\lstinputlisting[language={[KB]Ruby}, linerange={3-3,25-25}, style=codeStyle]{../codes/ruby/clsobj/person.rb}


\section{Constructors and destructors}

A constructor is a special function which is responsible for preparing the object to be created. 
The preparation, mostly, is concerned by initializing variables or calling some functions.

Once an object is deleted or out of scope, it is no longer needed. 
The destructor is a function which is called before deleting an object.
It can be used to free external resources used by the object before it is terminated.

\subsection{C++}

The constructor in C++ takes the same name as the class without a return type;
It can have arguments or not.
As for the destructor, it has the same name as the class prefixed by a tilde \keyword{\char`\~}.

\lstinputlisting[language={[KB]C++}, linerange={4-19,34-34}, style=codeStyle]{../codes/cpp/clsobj/person0.cpp}

To create an object in C++, you can create:
\begin{itemize}
	\item an automatically destroyed object when it goes out of scope, or
	\item a dynamically created object of which the address is binded to a pointer
\end{itemize}

\lstinputlisting[language={[KB]C++}, linerange={40-41}, style=codeStyle]{../codes/cpp/clsobj/person0.cpp}

To free the allocated object memory, in the second case, you can call \keyword{delete}. 
If the pointer you are deleting is zero, nothing will happen. 
Deleting a pointer twice will cause problems; This is why it is recommended to set is to zero right after you delete it.

\lstinputlisting[language={[KB]C++}, linerange={48-48}, style=codeStyle]{../codes/cpp/clsobj/person0.cpp}

\subsection{Java}

The constructor, in Java, is a function with the class name without a return type.
There is no destructor in Java, because the objects are heap allocated and heap allocated. 
Finalizers are like destructors in purpose: close files, sockets, etc. 
But, they are not called immediately after the object is freed. 
When the garbage collector collects an object with a finalizer, it enqueue it to be finalized. 
But, there is no guarantee that the finalyzer will ever be called; The application can exit without waiting the object to be finalyzed. 

\lstinputlisting[language={[KB]Java}, linerange={3-3,9-19,43-43}, style=codeStyle]{../codes/java/src/clsobj/Person.java}

To create a new object, use the keyword \keyword{new}.

\lstinputlisting[language={[KB]Java}, linerange={32-32}, style=codeStyle]{../codes/java/src/clsobj/Person.java}

To fasten the destruction of an object, you can assign \keyword{null} to all variables referencing it.

\lstinputlisting[language={[KB]Java}, linerange={39-39}, style=codeStyle]{../codes/java/src/clsobj/Person.java}

\subsection{Javascript}


In ES6, the constructor is a function defined using the keyword \keyword{constructor}.
There is no destructor function.

\lstinputlisting[language={[KB]Javascript}, linerange={1-6,15-15}, style=codeStyle]{../codes/javascript/clsobj/person.js}

Actually, a function can be used to define a prototype (class) and it is in the same time a constructor.

\lstinputlisting[language={[KB]Javascript}, linerange={1-5}, style=codeStyle]{../codes/javascript/clsobj/person2.js}

To create a new object, you use the keyword \keyword{new}

\lstinputlisting[language={[KB]Javascript}, linerange={19-19}, style=codeStyle]{../codes/javascript/clsobj/person.js}

\subsection{Lua}

In class declaration, we declared a class as a meta-table. 
The constructor is a function which has a name chosen by the programmer, usually \keyword{new} or \keyword{create}. 
This function must return an object to which you have to set a meta-table (our class) using the method \keyword{setmetatable}

\lstinputlisting[language={[KB]Lua}, linerange={4-7}, style=codeStyle]{../codes/lua/clsobj/person.lua}

Then to create a new object, we simply call that function.

\lstinputlisting[language={[KB]Lua}, linerange={19-19}, style=codeStyle]{../codes/lua/clsobj/person.lua}

Another fancy way to create a constructor is by using the meta-method \keyword{\_\_call} which allows us to call our meta-table as a function. 

\lstinputlisting[language={[KB]Lua}, linerange={4-9}, style=codeStyle]{../codes/lua/clsobj/person2.lua}

Then, we create a new object as follows

\lstinputlisting[language={[KB]Lua}, linerange={21-21}, style=codeStyle]{../codes/lua/clsobj/person2.lua}

\subsection{Perl}

In Perl, the constructor is a subroutine called \keyword{new}. 
The arguments are shifted from the global variable \keyword{@\_} where the first one is the class itself.
You have to create a hash and marking it with a package (class = package) name using \keyword{bless}.

When the last reference to an object goes away, the object is destroyed.
In this case, Perl will call the method \keyword{DESTROY} if it is defined.

\lstinputlisting[language={[KB]Perl}, linerange={3-23,34-34}, style=codeStyle]{../codes/perl/clsobj/person.pl}

To create a new object, either you use the keyword \keyword{new} or use the arrow function.  
If you use the second method, you can call your constructor whatever you want; But, by convention it is \keyword{new}.

\lstinputlisting[language={[KB]Perl}, linerange={36-37}, style=codeStyle]{../codes/perl/clsobj/person.pl}

To delete a reference, you use \keyword{undef} which will trigger the destructor.

\lstinputlisting[language={[KB]Perl}, linerange={44-44}, style=codeStyle]{../codes/perl/clsobj/person.pl}

\subsection{PHP}

The constructor is a function called \keyword{\_\_construct} and the destructor is a function called \keyword{\_\_destruct}.

\lstinputlisting[language={[KB]PHP}, linerange={2-2,8-17,27-27}, style=codeStyle]{../codes/php/clsobj/person.php}

To create an instance of the class, the keyword \keyword{new} is used.

\lstinputlisting[language={[KB]PHP}, linerange={29-29}, style=codeStyle]{../codes/php/clsobj/person.php}

To delete a reference, the keyword \keyword{unset} is used.

\lstinputlisting[language={[KB]PHP}, linerange={37-37}, style=codeStyle]{../codes/php/clsobj/person.php}

\subsection{Python}

The constructor is a function called \keyword{\_\_init\_\_} and the destructor is a function called \keyword{\_\_del\_\_}.

\lstinputlisting[language={[KB]Python}, linerange={4-4,8-15}, style=codeStyle]{../codes/python/clsobj/person.py}

To create an object, we call the class as a function

\lstinputlisting[language={[KB]Python}, linerange={24-24}, style=codeStyle]{../codes/python/clsobj/person.py}

To delete a reference, the keyword \keyword{del} is used.

\lstinputlisting[language={[KB]Python}, linerange={32-32}, style=codeStyle]{../codes/python/clsobj/person.py}


\subsection{Ruby}

The constructor is a function called \keyword{initialize}.
Ruby does not have a destructor, but it has a finalizer.
To bind the object with a finalizing function, you have to call \keyword{ObjectSpace.define\_finalizer} in the constructor.
The finalizer, like Java, can never be called.

\lstinputlisting[language={[KB]Ruby}, linerange={3-17,25-25}, style=codeStyle]{../codes/ruby/clsobj/person.rb}

To create a new object from our class, we call its function \keyword{new}.

\lstinputlisting[language={[KB]Ruby}, linerange={27-27}, style=codeStyle]{../codes/ruby/clsobj/person.rb}

To free a reference from an object, you can assign it the \keyword{nil} value.

\lstinputlisting[language={[KB]Ruby}, linerange={35-35}, style=codeStyle]{../codes/ruby/clsobj/person.rb}

\section{Members}

There are three types of members: 
\begin{itemize}
	\item Field: They are state variables. For example: a person has a name, birth year, etc.
	\item Methods: Procedures which define the behavior of the object. For example: a person can talk, walk, etc.
	\item Properties: They are something between a field and a method. The read/write syntax is similar to fields' but it is translated into getters/setters methods.
\end{itemize}

A member can be accessed as: 
\begin{itemize}
	\item Class member: It is shared between all the instances of this class.
	\item Object member: The member is specific to the instance (object)
\end{itemize}

For properties, lets say: we have a class Rectangle which is composed of height and width. 
We want to keep the width, always, bigger or equal to the height.
For the sake of the example, suppose when we want to get the height we add 1 and when we want to get the width we add 2.
Also, suppose only the width has a setter and the height will receive its value based on the previous width and its setter's value.
We assign the width twice: 50 and 20. 
Then, we use an internal function \textbf{info} which shows the state of the two fields. 
Finally, we use getters over the two fields and print the recovered values. 
The result in the languages which support properties, or has a way to emulate them, should be as follows
\begin{lstlisting}[style=shellStyle]
Width: 50, Height: 20
w: 52, h: 21
\end{lstlisting}  

\subsection{C++}

Fields are defined by type and name inside the class header. 
Static fields are defined using the keyword \keyword{static}.

\lstinputlisting[language={[KB]C++}, linerange={31-33}, style=codeStyle]{../codes/cpp/clsobj/person0.cpp}

Non constant class (static) fields must be initialized outside the header and not inside it. 

\lstinputlisting[language={[KB]C++}, linerange={36-36}, style=codeStyle]{../codes/cpp/clsobj/person0.cpp} 

Methods can be defined inside the class header as in this example.
Static methods must be defined using the keyword \keyword{static}. 

\lstinputlisting[language={[KB]C++}, linerange={20-27}, style=codeStyle]{../codes/cpp/clsobj/person0.cpp}

To call a static method, you should use class name. 
As for the object method, if the reference is a pointer use arrow annotation.

\lstinputlisting[language={[KB]C++}, linerange={43-45}, style=codeStyle]{../codes/cpp/clsobj/person0.cpp}

There are no properties in C++, but they can be emulated by overriding assigning operator.

\subsection{Java}

Fields are defined by access modifier (See Encapsulation chapter), type and name. 
Class (static) fields are defined using the keyword \keyword{static}.
All fields must be defined inside the class block; They can be initialized without needing a constructor. 
In fact, they are automatically initialized: integers to 0, objects no Null, etc. 

\lstinputlisting[language={[KB]Java}, linerange={5-7}, style=codeStyle]{../codes/java/src/clsobj/Person.java}

Methods are defined inside the class block where static ones are distinguished by the keyword \keyword{static}.

\lstinputlisting[language={[KB]Java}, linerange={21-28}, style=codeStyle]{../codes/java/src/clsobj/Person.java}

Static methods are called using the class name; But, also, they can be called from the instance. 

\lstinputlisting[language={[KB]Java}, linerange={34-36}, style=codeStyle]{../codes/java/src/clsobj/Person.java}

There are no properties in Java, you have to define your getters/setters and use them as methods. 
As far as we know, there is no mechanism to emulate their functionality either.


\subsection{Javascript}

The fields are defined inside the class body (either ES6 class or function) using the keyword \keyword{this}. 
You can define them using two methods (they are the same), as shown in the example.

\lstinputlisting[language={[KB]Javascript}, linerange={3-4}, style=codeStyle]{../codes/javascript/clsobj/person.js}

As for static fields, you can use the pattern <class name>.<field> to access it. 
The field must be initialized outside the class definition.

\lstinputlisting[language={[KB]Javascript}, linerange={17-17}, style=codeStyle]{../codes/javascript/clsobj/person.js}

Methods are defined inside the class definition in ES6. 
Also, static methods are preceded by the keyword \keyword{static}. 

\lstinputlisting[language={[KB]Javascript}, linerange={1-1,8-15}, style=codeStyle]{../codes/javascript/clsobj/person.js}

If the class is defined using a function (which is the real definition in javascript), you can define functions inside the constructor using the keyword \keyword{this}. 
Also, you can define them outside the constructor by assigning a function to the class's prototype.

\lstinputlisting[language={[KB]Javascript}, linerange={9-15}, style=codeStyle]{../codes/javascript/clsobj/person2.js}

Properties can be defined using \keyword{Object.defineProperties} and the keywords \keyword{get} and \keyword{set}.

\lstinputlisting[language={[KB]Javascript}, linerange={9-11,13-14,22-25,27-35}, style=codeStyle]{../codes/javascript/clsobj/property.js}

\subsection{Lua}

The fields are defined inside the table which will be our object. 
In our example, a table is created inside the constructor then the class table is set to be its meta-table. 
To define a static field, it can be assigned to the meta-table (our class).

\lstinputlisting[language={[KB]Lua}, linerange={4-9}, style=codeStyle]{../codes/lua/clsobj/person.lua}

To define dynamic methods, there are two ways where the colon (\keyword{:}) will add \keyword{self} implicitly.
\begin{lstlisting}[style=codeStyle, language={[KB]Lua}]
function ClassName.method1(self)
end
function ClassName:method2()
end
\end{lstlisting} 

As for static methods, they are defined as \textit{method1} without \keyword{self} keyword.

\lstinputlisting[language={[KB]Lua}, linerange={11-17}, style=codeStyle]{../codes/lua/clsobj/person.lua}

To call the methods, there are two ways for dynamic methods.

\lstinputlisting[language={[KB]Lua}, linerange={22-24}, style=codeStyle]{../codes/lua/clsobj/person.lua}

Properties can be defined by using the meta-methods \keyword{\_\_index} and \keyword{\_\_newindex}.
When the interpreter can not find a field, it calls the \keyword{\_\_index} meta-method. 
It has \keyword{self} and a key as arguments, and can be used to define getters in our case. 
You have to verify if the key exists already and return the member, otherwise your methods will not be known by the interpreter. 
\keyword{\_\_newindex} meta-method is used for table update and can be used as a setter. 

\lstinputlisting[language={[KB]Lua}, linerange={1-2,7-7,9-9,11-15,22-24,33-38}, style=codeStyle]{../codes/lua/clsobj/property.lua}

\subsection{Perl}

Object fields are defined in the hash which will be returned by the \keyword{new} subroutine as the new object. 

\lstinputlisting[language={[KB]Perl}, linerange={10-13}, style=codeStyle]{../codes/perl/clsobj/person.pl}

Class (static) fields are defined outside the new subroutine as variable scoped at the file level using \keyword{my} keyword.
Or you can define a package level variable using the keyword \keyword{our}.

\lstinputlisting[language={[KB]Perl}, linerange={6-6}, style=codeStyle]{../codes/perl/clsobj/person.pl}

There is no difference between dynamic and static methods. 
If the method is called as an object one, the object will be passed as the first argument. 
If it is called as a class one, the class name will be passed as the first argument. 
The implementation of the method will decide its access type.

\lstinputlisting[language={[KB]Perl}, linerange={25-32}, style=codeStyle]{../codes/perl/clsobj/person.pl}

As said, the difference between dynamic and static methods is in how they are called. 

\lstinputlisting[language={[KB]Perl}, linerange={39-41}, style=codeStyle]{../codes/perl/clsobj/person.pl}

Properties in Perl do not follow the definition we gave in this section; 
Sure we can define setters/getters, but they do not behave as attributes. 
A subroutine which has two arguments (the object and the value) is a setter.
If there is just one, then it is a getter. 

\lstinputlisting[language={[KB]Perl}, linerange={3-3,14-17,25-33,40-46}, style=codeStyle]{../codes/perl/clsobj/property.pl}

\subsection{PHP}

The fields are defined by access, type and name.
In PHP, there are called properties; But, we rather call them fields to differentiate them from the properties we defined earlier.
A static field is defined by the keyword \keyword{static}.

\lstinputlisting[language={[KB]PHP}, linerange={2-7,27-27}, style=codeStyle]{../codes/php/clsobj/person.php}

There are no difference between static and dynamic functions in header syntax. 
The difference is in implementation: the static one can access just static fields by using the keyword \keyword{self} instead of \keyword{this}.

\lstinputlisting[language={[KB]PHP}, linerange={2-2,19-25,27-27}, style=codeStyle]{../codes/php/clsobj/person.php}

The call is different between dynamic and static functions.

\lstinputlisting[language={[KB]PHP}, linerange={32-34}, style=codeStyle]{../codes/php/clsobj/person.php}

Properties getters/setters can be defined using php magic methods \keyword{\_\_get} and \keyword{\_\_set}.
It is considered bad practice though, and the alternative is to define getters and setters specified for each property.

\lstinputlisting[language={[KB]PHP}, linerange={2-2,11-12,21-37}, style=codeStyle]{../codes/php/clsobj/property.php}

\subsection{Python}

Static fields are defined inside the class block, while dynamic fields are defined inside the constructor using the keyword \keyword{self}. 
In pure Python, the dynamic fields of an object (instance) are stored in a dictionary \keyword{self.\_\_dict\_\_}.
The static field is accessed by the class name, not by \keyword{self}.
Also, static fields are stored in other dictionary bounded to the class, not the instance.

\lstinputlisting[language={[KB]Python}, linerange={4-11}, style=codeStyle]{../codes/python/clsobj/person.py}

Methods are defined using the keyword \keyword{def} inside the class block. 
There is no difference between static and dynamic methods in term of header syntax. 
But in Python 2.6+, you can use the decorator \keyword{\@staticmethod} to mark a static method. 

\lstinputlisting[language={[KB]Python}, linerange={4-4,17-22}, style=codeStyle]{../codes/python/clsobj/person.py}

The dynamic methods are accessed via the instance while the static ones are accessed using the class name.

\lstinputlisting[language={[KB]Python}, linerange={27-29}, style=codeStyle]{../codes/python/clsobj/person.py}

Properties can be defined using the new style classes (object as superclass) for Python 2.2+.
Starting from Python 2.6, there are decorators to define setters and getters.
In the example, the implementation is omitted.

\lstinputlisting[language={[KB]Python}, linerange={4-4,13-14,16-18,20-22, 28-33}, style=codeStyle]{../codes/python/clsobj/property.py}

\subsection{Ruby}

Static fields are defined inside the class block using \keyword{\@\@}, while dynamic fields are defined inside the constructor or the class block using the keyword \keyword{\@}. 

\lstinputlisting[language={[KB]Ruby}, linerange={3-9,11-11,25-25}, style=codeStyle]{../codes/ruby/clsobj/person.rb}

Methods are defined using the keyword \keyword{def} and delimited by the keyword \textbf{end}. 
Static methods always begin with the keyword \keyword{self}.
Also, methods without arguments do not need round brackets \keyword{()}.

\lstinputlisting[language={[KB]Ruby}, linerange={3-3,18-25}, style=codeStyle]{../codes/ruby/clsobj/person.rb}

We call dynamic methods using the instance name and static ones using the class name. 
Round brackets can be omitted if no argument is expected.

\lstinputlisting[language={[KB]Ruby}, linerange={30-32}, style=codeStyle]{../codes/ruby/clsobj/person.rb}

Properties can be defined by a field using a no-arguments method as a getter and another with the template \textbf{<prperty name> = (value)} as a setter.

\lstinputlisting[language={[KB]Ruby}, linerange={3-3,9-17,24-24,30-36}, style=codeStyle]{../codes/ruby/clsobj/property.rb}

Also, there are automatically implemented getters/setters in Ruby

\begin{lstlisting}[style=codeStyle, language={[KB]Ruby}]
class Rectangle
	attr_accessor :width # read/write
	attr_reader :height # read only
	attr_writer :bar # write only
end 
\end{lstlisting} 

\section{Object methods}

These are methods inherited from the Object class, or as called by some languages: magic methods.
In here, we present the methods which most programming languages agree on:
\begin{itemize}
	\item String representation: When an object is concatenated with a string, it can act as string by calling this function.
	\item Object copy: A function which enables an object to create a clone of itself.
	\item Value equality: A function which helps to decide if an object equals another based on some criteria (their fields).
	\item Object comparison: A function which is used to decide if an object is greater, equal or lesser than another.
	\item Hash code: A function which returns a hash code for the object. 
\end{itemize}

In our example, we will implement our \textbf{Person} class, and the previously presented methods as follows:
\begin{itemize}
	\item String representation: The function must return a string containing the name and the year of birth.
	\item Object copy: The function must return a new object with the same name but with plus one year to the current birth year.
	\item Value equality: The function returns true if the objects have the same value for the field called \textbf{name}.
	\item Object comparison: The comparison is made on birth years; If they are equal, then on the name.
	\item Hash code: The hash code will be based on the name (we can add the year as well, but it will be a long code). 
\end{itemize}


\subsection{C++}

In C++, there are no methods inherited from the object class because there is no universal base-class object. 
But, C++ support operations overloading which can replace base-class methods.
To overload an operation for a class based on its fields, you have to define these operations as friend operations to the class. 
This will allow them to access private members. 

\lstinputlisting[language={[KB]C++}, linerange={4-5, 18-21,24-24}, style=codeStyle]{../codes/cpp/clsobj/obj_meth.cpp}

\subsubsection{String representation}

There is no \keyword{toString} in C++, where an object can be transformed to a string when it is concatenated with one. 
But, operators such as \keyword{<{}<} can be overloaded to handle an object of a class as a string.   

\lstinputlisting[language={[KB]C++}, linerange={26-28}, style=codeStyle]{../codes/cpp/clsobj/obj_meth.cpp}

Then, you can call it as

\lstinputlisting[language={[KB]C++}, linerange={41-41,44-44}, style=codeStyle]{../codes/cpp/clsobj/obj_meth.cpp}

\subsubsection{Object copy}

You can just define a cloning function for the class and use it.

\subsubsection{Value equality}
 
You can overload the operator \keyword{==} to test the equality between two objects of the same class.  

\lstinputlisting[language={[KB]C++}, linerange={30-32}, style=codeStyle]{../codes/cpp/clsobj/obj_meth.cpp}

\subsubsection{Object comparison}

You can overload the operators \keyword{>}, \keyword{<}, \keyword{>=}, \keyword{<=} and \keyword{!=} to compare two objects of the same class.  
\keyword{std::string} class has its own \keyword{compare} method.

\lstinputlisting[language={[KB]C++}, linerange={34-37}, style=codeStyle]{../codes/cpp/clsobj/obj_meth.cpp}

\subsubsection{Hash code}

You can define a hashcode function for your current class.

\subsection{Java}

In Java, every class inherit from the universal class \keyword{Object}. 
This class defines some methods by default: string representation, object copy, value equality and hashcode.
To personalize them, you can override these functions in your class.

\subsubsection{String representation}

You can override \keyword{toString} which comes from the class \keyword{Object}.   

\lstinputlisting[language={[KB]Java}, linerange={26-26,36-39,65-65}, style=codeStyle]{../codes/java/src/clsobj/ObjMeth.java}

When the object is concatenated with strings, this function will be called automatically to represent this object as a string.

\lstinputlisting[language={[KB]Java}, linerange={9-9}, style=codeStyle]{../codes/java/src/clsobj/ObjMeth.java}

\subsubsection{Object copy}

The universal class \keyword{Object} implements a function \keyword{clone()} which performs a shallow copy.
That is, if a field is an object (not primary type), it will copy the reference and not create a new instance of it. 
To perform deep copy, you have to override this function. 
But before that, you have to implement the class \keyword{Clonable} otherwise your function will throw an exception \keyword{CloneNotSupportedException}.

\lstinputlisting[language={[KB]Java}, linerange={26-26,52-56,65-65}, style=codeStyle]{../codes/java/src/clsobj/ObjMeth.java}

\subsubsection{Value equality}

You can override the method \keyword{equals} which takes a variable of type \keyword{Object} as argument.
This is the other object to which we want to test our current object, and it can be of any other effective type. 
So, basically, you can test your current object against any other type if you wish to.
In our example, if the other object is not of the same type as the current's, the function returns false.

\lstinputlisting[language={[KB]Java}, linerange={26-26,46-50,65-65}, style=codeStyle]{../codes/java/src/clsobj/ObjMeth.java}

When testing equality with non primitive variables, you have to call this function. 
If you use \keyword{==} instead, you will have a reference equality test; that is, the variables will be tested if they have the same reference or not.

\lstinputlisting[language={[KB]Java}, linerange={16-17}, style=codeStyle]{../codes/java/src/clsobj/ObjMeth.java}

\subsubsection{Object comparison}

Objects, by default, do not implement a comparing method. 
If you want to compare an object with another, you can implement the interface \keyword{Comparable}. 
It is very useful since a lot of other methods are based on it such as \keyword{sort} of collections.
Then, you have to implement one method which is \keyword{compareTo}. 
It takes one argument of type \keyword{Object} which is the other object to compare to, unless you use generics to specify that object's type. 
This function returns a negative integer, zero, or a positive integer as this object is less than, equal to, or greater than the specified object.

\lstinputlisting[language={[KB]Java}, linerange={26-26,58-65}, style=codeStyle]{../codes/java/src/clsobj/ObjMeth.java}


\subsubsection{Hash code}

You can override \keyword{hashCode()} method to define specialized hash code calculation to a class.
\lstinputlisting[language={[KB]Java}, linerange={41-44}, style=codeStyle]{../codes/java/src/clsobj/ObjMeth.java}

\subsection{Javascript}

All objects in JavaScript are descended from \keyword{Object}; all objects inherit methods and properties from \keyword{Object.prototype}.

\subsubsection{String representation}

Every object has a \keyword{toString} method inherited from the universal class, and it can be overridden. 

\lstinputlisting[language={[KB]Javascript}, style=codeStyle]{../codes/javascript/clsobj/obj_meth.js}

\subsubsection{Object copy}

There is no method permitting an object to deep clone itself. 
You can use ES6 \keyword{Object.assign} to fuse an object's members to an empty one, but it will afford shallow copying. 
\begin{lstlisting}[language={[KB]Javascript}, style=codeStyle]
let obj2 = Object.assign({}, obj1);
\end{lstlisting} 
To deep copy an object, you can use libraries such as \nameword{lodash} via its method \keyword{clonedeep}

\subsubsection{Value equality}

There is no value equality method; you can define your own.

\subsubsection{Object comparison}

There is no comparison method; you can define your own.

\subsubsection{Hash code}

There is no hash code method; you can define your own.

\subsection{Lua}

Lua is prototype-based OOP language where an object is a meta-table. 
There exists some meta-methods defined for these meta-tables and can be overridden.
 
\subsubsection{String representation}

By defining the meta-method \keyword{\_\_tostring}, the object can be used as a string.

\lstinputlisting[language={[KB]Lua}, linerange={8-10}, style=codeStyle]{../codes/lua/clsobj/objmeth.lua}

Then, the object can be used as as string

\lstinputlisting[language={[KB]Lua}, linerange={8-10}, style=codeStyle]{../codes/lua/clsobj/objmeth.lua}

\subsubsection{Object copy}

To deep copy an object, you have to implement it yourself since there is no meta-method for this.

\subsubsection{Value equality}

The equality of two objects of a class can be defined using the meta-method \keyword{\_\_eq} which has two objects as arguments. 

\lstinputlisting[language={[KB]Lua}, linerange={12-14}, style=codeStyle]{../codes/lua/clsobj/objmeth.lua}

\subsubsection{Object comparison}

Besides equality, there are two more meta-methods: less than \keyword{\_\_lt} and less than or equals \keyword{\_\_le}. 
The other relations can be inferred by negating these three.
Strings can be compared by default.

\lstinputlisting[language={[KB]Lua}, linerange={16-22}, style=codeStyle]{../codes/lua/clsobj/objmeth.lua}

To call them:

\lstinputlisting[language={[KB]Lua}, linerange={28-32}, style=codeStyle]{../codes/lua/clsobj/objmeth.lua}

\subsubsection{Hash code}

You have to implement your own hash code method.

\subsection{Perl}

In Perl, all classes inherit from a base class named \keyword{UNIVERSAL}.
This class affords some methods other than the ones we are discussing here, the most important ones:
\begin{itemize}
	\item \textbf{\$obj->isa( TYPE )} which verifies if this object is an instance of a certain type.
	\item \textbf{\$obj->can( METHOD )} which verifies if this object affords a certain method.
\end{itemize}
By overloading some operations, our special methods can be emulated.

\subsubsection{String representation}

The string representation of an object can be done by overloading the stringification operator. 

\lstinputlisting[language={[KB]Perl}, linerange={16-20}, style=codeStyle]{../codes/perl/clsobj/objmeth.pl}

Stringification is not the only object transformation, there are other operations that can be overloaded to treat the object in different contexts:

\begin{itemize}
	\item Boolification by overloading \keyword{bool}, the object can be used as a boolean \textbf{if (\$obj) \{...\}}
	\item Numification by overloading \keyword{0+}, the object can be used as a number \textbf{say \$obj + 1;}
	\item Regexification by overloading \keyword{qr}, the object can be used as a regex \textbf{if (\$str =~ /\$obj/)}
	\item Scalarification by overloading \keyword{\$\{\}}, the object can be used as a scalar ref \textbf{say \$\$obj;}
	\item Arrayification by overloading \keyword{@\{\}}, the object can be used as an array ref \textbf{say for @\$obj;}
	\item Hashification by overloading \keyword{\%\{\}}, the object can be used as a hash ref \textbf{say for keys \%\$obj;}
	\item Codeification by overloading \keyword{\&\{\}}, the object can be used as a code ref \textbf{say \$obj->(1, 2, 3);}
	\item Globification by overloading \keyword{*\{\}}, the object can be used as a glob ref \textbf{say *\$obj;}
\end{itemize}

\subsubsection{Object copy}

You can write your own cloning function since there is no default one.

\subsubsection{Value equality}

Perl uses operations such as \keyword{==} for numeric equality and \keyword{eq} for strings equality. 
Like other operations, they can be overloaded.
We can overload numeric equality for that matter, or we can define a numification of the object that gives us numeric values compatible to what we want to achieve.

\lstinputlisting[language={[KB]Perl}, linerange={16-16,21-24}, style=codeStyle]{../codes/perl/clsobj/objmeth.pl}

\subsubsection{Object comparison}

Likewise, comparing operations: \keyword{<=>} for numerals and \keyword{cmp} can be overloaded. 
They return -1, 0 or 1 if the first element is less, equal or greater than the second.
Do not use the same operation inside its overloaded implementation, otherwise you will have an error: Use of uninitialized value in numeric comparison.
Other logic operations can be overloaded such as \keyword{>}, \keyword{<}, etc.

\subsubsection{Hash code}

There is no hash code method in Perl.

\subsection{PHP}

There is no universal base class in PHP.
But there exists some reserved keywords for methods names known as magic methods.
String representation and object cloning fall in this category of methods.

\subsubsection{String representation}

The \keyword{\_\_toString()} method allows a class to decide how it will react when it is treated like a string.

\lstinputlisting[language={[KB]PHP}, linerange={2-2,12-14,20-20}, style=codeStyle]{../codes/php/clsobj/objmeth.php}

\subsubsection{Object copy}

An object copy is created by using the \keyword{clone} keyword (which calls the object's \keyword{\_\_clone()} method if possible). An object's \keyword{\_\_clone()} method cannot be called directly.

\lstinputlisting[language={[KB]PHP}, linerange={2-2,16-20}, style=codeStyle]{../codes/php/clsobj/objmeth.php}

\subsubsection{Value equality}

There is no magic method for equality, and no operation overload. 
Using \keyword{==}, two objects are equal if they have the same attributes and values, and they are instances of the same class.
Using \keyword{===}, two object variables are equal if they point to the same object (reference equality).

\lstinputlisting[language={[KB]PHP}, linerange={22-22,26-26,29-30}, style=codeStyle]{../codes/php/clsobj/objmeth.php}

\subsubsection{Object comparison}

No comparison, you have to define your own. 

\subsubsection{Hash code}

There is no internal hash code method for classes.

\subsection{Python}

In new Python syntax, all classes inherit from the class \keyword{object}. 
There exists many magic methods in Python, which are called upon using an object as argument to a built-in method. 
For example, the magic method \keyword{\_\_str\_\_} of a class is used when an instance of that class is passed as argument to the built-in method \keyword{str}.
Besides the methods we are presenting here, there exists many magic methods such those for arithmetic operations, for built-in unary methods, etc.

\subsubsection{String representation}

To use an object as a string, you have to define the magic method \keyword{\_\_str\_\_}.

\lstinputlisting[language={[KB]Python}, linerange={4-4,10-11}, style=codeStyle]{../codes/python/clsobj/objmeth.py}

Then, you can use it by calling the method \keyword{str}

\lstinputlisting[language={[KB]Python}, linerange={27-27,29-29}, style=codeStyle]{../codes/python/clsobj/objmeth.py}

\subsubsection{Object copy}

To clone an object, you need to use the module \nameword{copy} which defines two methods: \keyword{copy} for shallow copy and \keyword{deepcopy} for deep copy.

\lstinputlisting[language={[KB]Python}, linerange={27-27,32-32}, style=codeStyle]{../codes/python/clsobj/objmeth.py}

To tell those methods how to copy an object, you have to define the magic methods: \keyword{\_\_copy\_\_} and \keyword{\_\_deepcopy\_\_}.

\lstinputlisting[language={[KB]Python}, linerange={4-4,13-14}, style=codeStyle]{../codes/python/clsobj/objmeth.py}

\subsubsection{Value equality}

The equality can be defined using the magic method \keyword{\_\_eq\_\_}. 
It is called when you use the equality test \keyword{==}.

\lstinputlisting[language={[KB]Python}, linerange={4-4, 16-17, 27-27, 32-32, 34-34}, style=codeStyle]{../codes/python/clsobj/objmeth.py}

\subsubsection{Object comparison}

Comparing objects can be done using magic method \textbf{\_\_cmp\_\_} which returns 0 if they are equal, a negative number if the caller is less than the other object, a positive number otherwise.
It is no longer available for Python3 due to redundancy with other magic methods. 
The comparison methods replacing it are: equal \keyword{\_\_eq\_\_}, not equal \keyword{\_\_ne\_\_}, less than \textbf{\_\_lt\_\_}, greater than \textbf{\_\_gt\_\_}, less than or equals to \textbf{\_\_le\_\_} and greater than or equals to \textbf{\_\_ge\_\_}.

\lstinputlisting[language={[KB]Python}, linerange={4-4, 19-20, 27-27, 32-32, 36-36}, style=codeStyle]{../codes/python/clsobj/objmeth.py}

\subsubsection{Hash code}

Magic method \keyword{\_\_hash\_\_} is used to define how an object generates its hash code.
It is called when we use the object as argument of the method \keyword{hash}.

\lstinputlisting[language={[KB]Python}, linerange={4-4, 22-23, 27-27, 30-30}, style=codeStyle]{../codes/python/clsobj/objmeth.py}

\subsection{Ruby}

\keyword{Object} is the default root of all Ruby objects.
Besides our methods, this class defines other ones.

\subsubsection{String representation}

By overriding the method \keyword{to\_s}, you can use the object as a string.

\lstinputlisting[language={[KB]Ruby}, linerange={3-3,18-20,39-41,44-44}, style=codeStyle]{../codes/ruby/clsobj/objmeth.rb}

\subsubsection{Object copy}

To create an object copy, there are two methods: \keyword{clone} and \keyword{dup}. 
\keyword{dup} creates a new copy of the object, but its original members are shared. 
Which means, if you copy an object then modify the attributes in the copy, this will affect the original.
Also, it does not copy methods from the original object.
In addition, it does not preserve the frozen state.

The two methods: \keyword{initialize\_dup} and \keyword{initialize\_clone} must be overridden to ensure a specialized copy.
A shared method between them is \keyword{initialize\_copy} which is called when they are done.

\lstinputlisting[language={[KB]Ruby}, linerange={3-3,12-16,39-41,47-47}, style=codeStyle]{../codes/ruby/clsobj/objmeth.rb}

\subsubsection{Value equality}

There are three methods for equality:
\begin{itemize}
	\item \keyword{==} It is used to test reference equality. 
	Typically, this method is overridden in descendant classes to provide class-specific meaning.
	
	\item \keyword{equal?} Same as \keyword{==}, but it is used to determine object identity and should never be overridden.
	
	\item \keyword{eql?} It is used by \keyword{Hash} collection to test members equality. 
	It tests if the two objects refer to the same hash key. 
\end{itemize}

\lstinputlisting[language={[KB]Ruby}, linerange={3-3,31-33,39-41,47-47,49-49}, style=codeStyle]{../codes/ruby/clsobj/objmeth.rb}

\subsubsection{Object comparison}

To compare two objects, the method \keyword{<=>} is used. 
When redefined, it should return: -1 when self is smaller than other, 0 when self is equal to other and 1 when self is bigger than other. Nil means the two values could not be compared.

When you define <=>, you can include Comparable to gain the methods <=, <, >=, > and between?.

\lstinputlisting[language={[KB]Ruby}, linerange={3-4,22-29,39-42,47-47,50-52}, style=codeStyle]{../codes/ruby/clsobj/objmeth.rb}

\subsubsection{Hash code}

To generate a hash value for an object, the method \keyword{hash} is used. 
It must follow the condition: a.eql?(b) implies a.hash == b.hash, because this function is used with \keyword{eql?} by the class \keyword{Hash} to determine if two objects reference the same hash key.


The hash value for an object may not be identical across invocations or implementations of ruby. 
If you need a stable identifier across ruby invocations and implementations you will need to generate one with a custom method.

\lstinputlisting[language={[KB]Ruby}, linerange={3-3,35-41,45-45}, style=codeStyle]{../codes/ruby/clsobj/objmeth.rb}

%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================