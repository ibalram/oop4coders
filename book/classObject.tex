%=====================================================================
\ifx\wholebook\relax\else
	\documentclass{KodeBook}
	\input{calls}
	\begin{document}
	\chapter{Class and Object}
\fi
%=====================================================================

\begin{introduction}
	Abstraction is the first pillar of OOP. 
	From a perception of an entity in a system or a context, we focus on certain aspects and ignore unnecessary ones.
	This entity is represented by a class or a prototype, with some attributes and methods.
	In this chapter, we will show how a class  or prototype  is implemented in each language.
\end{introduction}

\section{Class declaration}

\subsection{C++}

\lstinputlisting[language=C++, linerange={4-5,34-34}, style=codeStyle]{../cpp/person0.cpp}

\subsection{Java}

\lstinputlisting[language=Java, linerange={1-1,40-40}, style=codeStyle]{../java/src/Person.java}

\subsection{Javascript}

\lstinputlisting[linerange={1-1,11-11}, style=codeStyle]{../javascript/person.js}

\lstinputlisting[linerange={1-1,5-5}, style=codeStyle]{../javascript/person2.js}

\subsection{Lua}

\lstinputlisting[language={[5.2]Lua}, linerange={1-2}, style=codeStyle]{../lua/person.lua}

\subsection{Perl}

\lstinputlisting[language=Perl, linerange={4-4}, style=codeStyle]{../perl/person.pl}

\subsection{PHP}

\lstinputlisting[language=PHP, linerange={2-2,27-27}, style=codeStyle]{../php/person.php}

\subsection{Python}

\lstinputlisting[language=Python, linerange={4-4}, style=codeStyle]{../python/person.py}

\subsection{Ruby}

\lstinputlisting[language=Ruby, linerange={3-3,19-19}, style=codeStyle]{../ruby/person.rb}


\section{Constructors and destructors}

\subsection{C++}

\lstinputlisting[language=C++, linerange={4-19,34-34}, style=codeStyle]{../cpp/person0.cpp}

\lstinputlisting[language=C++, linerange={40-41}, style=codeStyle]{../cpp/person0.cpp}

\lstinputlisting[language=C++, linerange={48-48}, style=codeStyle]{../cpp/person0.cpp}

\subsection{Java}

\lstinputlisting[language=Java, linerange={1-1,5-17,40-40}, style=codeStyle]{../java/src/Person.java}

\lstinputlisting[language=Java, linerange={28-28}, style=codeStyle]{../java/src/Person.java}

\lstinputlisting[language=Java, linerange={36-36}, style=codeStyle]{../java/src/Person.java}

\subsection{Javascript}

\lstinputlisting[linerange={1-6,15-15}, style=codeStyle]{../javascript/person.js}

\lstinputlisting[linerange={1-5}, style=codeStyle]{../javascript/person2.js}

\subsection{Lua}

\lstinputlisting[language={[5.2]Lua}, linerange={4-7}, style=codeStyle]{../lua/person.lua}

\lstinputlisting[language={[5.2]Lua}, linerange={19-19}, style=codeStyle]{../lua/person.lua}

\subsection{Perl}

\lstinputlisting[language=Perl, linerange={3-23,34-34}, style=codeStyle]{../perl/person.pl}

\lstinputlisting[language=Perl, linerange={36-36}, style=codeStyle]{../perl/person.pl}

\lstinputlisting[language=Perl, linerange={44-44}, style=codeStyle]{../perl/person.pl}

\subsection{PHP}

\lstinputlisting[language=PHP, linerange={2-2,8-17,27-27}, style=codeStyle]{../php/person.php}

\lstinputlisting[language=PHP, linerange={29-29}, style=codeStyle]{../php/person.php}

\lstinputlisting[language=PHP, linerange={37-37}, style=codeStyle]{../php/person.php}

for static members, we use self, for dynamic we use this

\subsection{Python}

\lstinputlisting[language=Python, linerange={4-4,8-15}, style=codeStyle]{../python/person.py}

\lstinputlisting[language=Python, linerange={24-24}, style=codeStyle]{../python/person.py}

\lstinputlisting[language=Python, linerange={32-32}, style=codeStyle]{../python/person.py}


\subsection{Ruby}

\lstinputlisting[language=Ruby, linerange={3-10,19-19}, style=codeStyle]{../ruby/person.rb}

\lstinputlisting[language=Ruby, linerange={21-21}, style=codeStyle]{../ruby/person.rb}

\lstinputlisting[language=Ruby, linerange={29-29}, style=codeStyle]{../ruby/person.rb}

\section{Members}

There are three types of members: 
\begin{itemize}
	\item Fields
	\item Methods
	\item Properties
\end{itemize}

A member can be accessed as: 
\begin{itemize}
	\item Class member: it is shared by all the instances of this class.
	\item Object member: the member is specific to the instance (object)
\end{itemize}


\subsection{C++}

fields: 
\lstinputlisting[language=C++, linerange={31-33}, style=codeStyle]{../cpp/person0.cpp}

Non constant class fields must be initialized outside the header and not inside it. 

\lstinputlisting[language=C++, linerange={36-36}, style=codeStyle]{../cpp/person0.cpp} 

Methods:
\lstinputlisting[language=C++, linerange={20-27}, style=codeStyle]{../cpp/person0.cpp}

\lstinputlisting[language=C++, linerange={43-45}, style=codeStyle]{../cpp/person0.cpp}


There are no properties in C++.

\subsection{Java}

\lstinputlisting[language=Java, linerange={2-4}, style=codeStyle]{../java/src/Person.java}

\lstinputlisting[language=Java, linerange={18-25}, style=codeStyle]{../java/src/Person.java}

There are no properties in Java.


\subsection{Javascript}

\lstinputlisting[linerange={3-4}, style=codeStyle]{../javascript/person.js}

\lstinputlisting[linerange={17-17}, style=codeStyle]{../javascript/person.js}

Methods: 

\lstinputlisting[linerange={1-1,8-15}, style=codeStyle]{../javascript/person.js}

\lstinputlisting[linerange={9-15}, style=codeStyle]{../javascript/person2.js}

getters and setters can be defined using keywords \textbf{get} and \textbf{set} in ES6.

\subsection{Lua}

\lstinputlisting[language={[5.2]Lua}, linerange={4-9}, style=codeStyle]{../lua/person.lua}

\lstinputlisting[language={[5.2]Lua}, linerange={11-17}, style=codeStyle]{../lua/person.lua}

\lstinputlisting[language={[5.2]Lua}, linerange={22-24}, style=codeStyle]{../lua/person.lua}


\subsection{Perl}

\lstinputlisting[language=Perl, linerange={10-13}, style=codeStyle]{../perl/person.pl}

\lstinputlisting[language=Perl, linerange={6-6}, style=codeStyle]{../perl/person.pl}

Methods

\lstinputlisting[language=Perl, linerange={25-32}, style=codeStyle]{../perl/person.pl}

\lstinputlisting[language=Perl, linerange={39-41}, style=codeStyle]{../perl/person.pl}

%TODO reedit
``\textit{A static method applies functionality to the class as a whole because it uses the name of the class. Therefore, functionality in static methods is applicable to all objects of the class. Generally, static methods ignore the first argument because they already know which class they are in. Therefore, constructors are static methods.}"

\subsection{PHP}

\lstinputlisting[language=PHP, linerange={2-7,27-27}, style=codeStyle]{../php/person.php}

\lstinputlisting[language=PHP, linerange={2-2,19-25,27-27}, style=codeStyle]{../php/person.php}

\lstinputlisting[language=PHP, linerange={32-34}, style=codeStyle]{../php/person.php}

\subsection{Python}

\lstinputlisting[language=Python, linerange={4-11}, style=codeStyle]{../python/person.py}

\subsection{Ruby}

\lstinputlisting[language=Ruby, linerange={3-10,19-19}, style=codeStyle]{../ruby/person.rb}

\lstinputlisting[language=Ruby, linerange={3-3,12-19}, style=codeStyle]{../ruby/person.rb}

\lstinputlisting[language=Ruby, linerange={24-26}, style=codeStyle]{../ruby/person.rb}


\section{Object methods}

\begin{itemize}
	\item String representation
	\item Object copy
	\item Value equality
	\item Object comparison
	\item Hash code
\end{itemize}


\subsection{C++}

There is no toString in C++, where an object can be transformed to a string when it is concatenated with one. 
But, operators such as \textbf{<<} can be redefined to handle an object of a class as a string. 
A condition to use such methods is to define them as friend, so they can access the class's internal elements.  

\lstinputlisting[language=C++, style=codeStyle]{../cpp/obj_meth.cpp}

\subsection{Java}

\lstinputlisting[language=Java, linerange={23-23,33-62}, style=codeStyle]{../java/src/ObjMeth.java}

\lstinputlisting[language=Java, linerange={4-17}, style=codeStyle]{../java/src/ObjMeth.java}

\subsection{Javascript}

\lstinputlisting[style=codeStyle]{../javascript/person.js}

\subsection{Lua}

\lstinputlisting[language={[5.2]Lua}, style=codeStyle]{../lua/objmeth.lua}

\subsection{Perl}

ToString can be customized by overriding the object's conversion operator. 

\lstinputlisting[language=Perl, style=codeStyle]{../perl/objmeth.pl}

\subsection{PHP}

\lstinputlisting[language=PHP, style=codeStyle]{../php/objmeth.php}

\subsection{Python}

\lstinputlisting[language=Python, style=codeStyle]{../python/objmeth.py}

Comparing method \textbf{\_\_cmp\_\_} is no longer available for Python3. 
But, other comparison methods are: \textbf{\_\_lt\_\_}, \textbf{\_\_gt\_\_}, etc.

\subsection{Ruby}

To create a copy, there are two methods: \textbf{clone} and \textbf{dup}. 
\textbf{dup} creates a new copy of the object, but its original members are shared. 
Which means, if I copy an object then modify the attributes in the copy, this will affect the original.

\lstinputlisting[language=Ruby, style=codeStyle]{../ruby/objmeth.rb}

The two methods (\textbf{initialize\_dup} and \textbf{initialize\_clone}) call \textbf{initialize\_copy} when they are done.


The hashCode in Ruby changes between sessions.
It means, if you execute the program and then re-execute it again, you will not have the same hashcode of an object.

%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================