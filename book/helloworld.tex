%=====================================================================
\ifx\wholebook\relax\else
	\documentclass{KodeBook}
	\input{calls}
	\begin{document}
	\chapter{Hello World}
\fi
%=====================================================================

%Introduction

\begin{introduction}
	This chapter is meant to introduce different oriented-object programming languages used in this book. 
	First of all, installing instructions must be presented to help anyone with zero knowledge about these languages. 
	Then, we will present different implementations of these languages from ``Hello world" to functions and exceptions. 
	We have to point out that this chapter introduces the basic syntax without diving in different OOP concepts.
	But, in case of languages with strong OOP, we have to present some concepts such as ``override" in ``exceptions".
\end{introduction}


\section{Getting started}

\subsection{C++}

C++ is a general-purpose compiled programming language which affords object-oriented paradigm among others. 
It was developed by \textbf{Bjarne Stroustrup} at Bell Labs since 1979.

To use C++ you have to install its compiler. 
The most used one is GNU g++\footnote{GNU g++: \url{gcc.gnu.org/}} which is distributed freely and available for most systems.

\subsubsection{Linux}
Simply install g++ on your system; on Ubuntu you, simply, type:
\begin{lstlisting}[style=shellStyle]
$ sudo apt-get update
$ sudo apt-get install g++
\end{lstlisting}

\subsubsection{Windows}

If you want to use g++ on Windows, you can install:
\begin{itemize}
	\item MinGW: \url{http://www.mingw.org} 
	\item CygWin: \url{http://www.cygwin.com} if you want to use Linux on Windows
\end{itemize}

You can use Microsoft Visual studio: \url{https://www.visualstudio.com/vs/visual-studio-express/}

Also, you can install Turbo C++ on \url{https://turboc.codeplex.com}

\subsection{Java}

Java is a general-purpose compiled programming language which is concurrent, class-based, object-oriented. 
It is intended to generate platform-independent programs. 
That is, the same compiled program called bytecodes will be able to execute in different machines and operating systems using a virtual machine. 
Developed by \textbf{James Gosling} at Sun Microsystems (acquired by Oracle Corporation) in 1995.

This is a detailed description on how to install Java \url{https://www.java.com/en/download/help/download_options.xml}.
Simply, to install Oracle JDK, download it from this link: \url{http://www.oracle.com/technetwork/java/javase/downloads/index.html}. 

As for OpenJDK, you can install it on Linux distributions following these instructions: \url{http://openjdk.java.net/install/}. 
On some distributions such as \textbf{Linux Mint}, it is installed by default.
For example, in Ubuntu you type:
\begin{lstlisting}[style=shellStyle]
$ sudo apt-get update
$ sudo apt-get install openjdk-8-jdk
\end{lstlisting}

It is recommended to use an IDE:
\begin{itemize}
	\item Eclipse: which is used in our case. \url{http://www.eclipse.org}
	\item IntelliJ IDEA: \url{https://www.jetbrains.com/idea/}
	\item NetBeans: \url{https://netbeans.org}
\end{itemize}

\subsection{Javascript}

JavaScript is an interpreted programming language for the web, which supports object-oriented paradigm. 
It is meant to be used as client-side programming language executed on different browser, but it can also execute on server side using NodeJs for example.
It was developed by Netscape Communications Corporation, and designed by \textbf{Brendan Eich} in 1995. 

Javascript can be used directly on any browser. 
Suppose we have a file called "func.js" containing a function "fact(n)" which calculates the factorial of a number. 
To use it, all you have to do is linking the file and calling the function in an HTML file:
\begin{lstlisting}[style=codeStyle]
<html>
  <head>
    <title>Functions</title>
      <script type="text/javascript" src="func.js">
      </script>
      <script type="text/javascript">
          function exec(){
              var n = document.getElementById("n").value;
              var res = "Fact(" + n + ")= ";
              res += fact(n);
              document.getElementById("result").innerHTML = res;
          }
      </script>
  </head>
    <body>
        Please enter an integer value: 
        <input type="number" id="n" />
        <button id="func" onclick="exec()">Factorial</button>
        <div id="result"></div>
    </body>
</html>
\end{lstlisting}


Or you can use \textbf{NodeJs} to execute it directly on the shell which is the case in our late examples. 
You can download it here: \url{https://nodejs.org/en/download/}. 
In case of some Linux distributions, you can install it from their repositories:
\begin{lstlisting}[style=shellStyle]
$ sudo apt-get update
$ sudo apt-get install nodejs
\end{lstlisting}

\subsection{Lua}

Lua is an interpreted programming language, which supports object-oriented paradigm. 
It was designed primarily for embedded systems.
Designed by Roberto Ierusalimschy, Luiz Henrique de Figueiredo, and Waldemar Celes in 1993.
It is mostly used as a scripting language for games development.

Download it from here: \url{http://lua-users.org/wiki/LuaBinaries}. 
In Ubuntu, you can install it by using its version number as:
\begin{lstlisting}[style=shellStyle]
$ sudo apt-get update
$ sudo apt-get install lua5.2
\end{lstlisting}


\subsection{Perl}

Lua is a general-purpose interpreted programming language, which supports oriented-object paradigm. 
It was developed by \textbf{Larry Wall} in 1987 to simplify report processing on Unix.
It is used as a CGI scripting language for web servers.

To install Perl, please refer to this page: \url{https://www.perl.org/get.html}. 
It is high probable that you have Perl installed on your Linux. 
As for Windows users, there are two projects: 
\begin{itemize}
	\item Strawberry Perl: \url{http://strawberryperl.com}
	\item ActiveState Perl: \url{http://www.activestate.com/activeperl/downloads}
\end{itemize}

\subsection{PHP}

PHP is a general-purpose server-side scripting language which supports oriented-object programming since version 3.0  and improved in version 5.0.
It was originally created by \textbf{Rasmus Lerdorf} in 1994. 

For a detailed description on how to install the server, please refer to this page: \url{http://php.net/manual/en/install.php}.
On Ubuntu, we just need the language:
\begin{lstlisting}[style=shellStyle]
$ sudo apt-get update
$ sudo apt-get install php
\end{lstlisting}
It will install a command-line interface (CLI) called "php"; used to execute a php file directly from the shell.

\subsection{Python}

Python is an interpreted general-purpose programming language, support multiple paradigms including OOP. 
It was created by \textbf{Guido van Rossum} and released in 1991.
It supports code readability as a design philosophy by using indentations as a mean of defining code blocks.

Refer to this page: \url{https://www.python.org/downloads/}. 
For Ubuntu, you can type:
\begin{lstlisting}[style=shellStyle]
$ sudo apt-get update
$ sudo apt-get install python
\end{lstlisting}
Or you can refer to this page for further information: \url{http://docs.python-guide.org/en/latest/starting/install3/linux/}.
You have to verify if it is already installed (Linux Mint has it by default).

\subsection{Ruby}

Ruby is an interpreted, object-oriented, general-purpose programming language. 
It was designed and developed by \textbf{Yukihiro Matsumoto} in 1990.

To install it, please refer to this page: \url{http://www.ruby-lang.org/en/documentation/installation/}. 
On Windows, you can use RubyInstaller: \url{https://rubyinstaller.org}.
On Linux systems, you can find it on their repositories, such as Ubuntu:
\begin{lstlisting}[style=shellStyle]
$ sudo apt-get update
$ sudo apt-get install ruby
\end{lstlisting}
You have to verify if it is already installed (Linux Mint has it by default).


\section{Languages features}

Before introducing oriented-object concepts of each language, how about a little comparison between our programming languages.

\begin{itemize}
	\item \textbf{Type safety}: is the extent to which a programming language prevents type errors. 
	\item \textbf{Type expression}: represents the type declaration. If it is explicit, the programmer have to specify the type of a variable or a method. If it is implicit, the type is inferred based on how the variables are being used.
	\item \textbf{Type checking}: When the code is verified for type constrains, this can be happen in compile-time (static check) or run-time (dynamic check).
\end{itemize}


\begin{table}
	\begin{tabular}{llll}
		\hline
		Language & Type safety & Type expression & Type checking \\
		\hline
		C++ & Weak & Explicit & Static \\
		\hline
		Java & Strong & Explicit & Static \\
		\hline
		Javascript & Weak & Implicit & Dynamic \\
		\hline
		Lua & Strong & Implicit & Dynamic \\
		\hline
		Perl & & Implicit & Dynamic \\
		\hline
		PHP & & implicit/optional explicit & Dynamic \\
		\hline
		Python & Strong & implicit/(v3.5+ optional explicit) & Dynamic \\
		\hline
		Ruby & Strong & implicit & Dynamic \\
		\hline
	\end{tabular}
\end{table}


\section{Hello world}

Let's start with a Hello World introductory set of codes. 


\subsection{C++}

A C++ program always has a main function, which represents the interface with the operating system. 
When you call a program (from shell for example), you actually calling this function. 
The main function is defined directly in the file and not inside a class or a structure.
%
\lstinputlisting[language=C++, style=codeStyle]{../cpp/helloworld.cpp}
%

Suppose we use g++ for C++. 
To compile this code, you can specify the output file's name or not
\begin{lstlisting}[style=shellStyle]
$ g++ helloworld.cpp 
$ g++ helloworld.cpp -o exec 
\end{lstlisting}
This will create a file \textbf{a.out}, which we can execute as follows
\begin{lstlisting}[style=shellStyle]
$ ./a.out
$ ./exec 
\end{lstlisting}

\subsection{Java}

In Java, a .java file can contain many classes, but only one with a public keyword. 
The public class must have the same name as the file. 
The main function is defined inside the main class.

\lstinputlisting[language=Java, style=codeStyle]{../java/src/HelloWorld.java}

To compile this code using command-line
\begin{lstlisting}[style=shellStyle]
$ javac HelloWorld.java
\end{lstlisting}
This will create a file \textbf{HelloWorld.class}, which we can be executed as follows
\begin{lstlisting}[style=shellStyle]
$ java HelloWorld
\end{lstlisting}

\subsection{Javascript}

Javascript is a scripting language; the instructions are written directly without a main class or a main function.
The program can be used side-by-side HTML, and therefore executed in a browser.

\lstinputlisting[style=codeStyle, firstline=6, lastline=9]{../javascript/helloworld.htm}

It can, also, be executed using nodeJs. 

\lstinputlisting[style=codeStyle]{../javascript/helloworld.js}

To execute it in command-line, you can use either one of these two commands
\begin{lstlisting}[style=shellStyle]
$ node helloworld.js
$ nodejs helloworld.js
\end{lstlisting}

\subsection{Lua}

Lua is a scripting language; the instructions are written directly without a main class or a main function.

\lstinputlisting[language={[5.2]Lua}, style=codeStyle]{../lua/helloworld.lua}

To execute it in command-line:
\begin{lstlisting}[style=shellStyle]
$ lua helloworld.lua
\end{lstlisting}

\subsection{Perl}

Perl is a scripting language; the instructions are written directly without a main class or a main function.

\lstinputlisting[language=Perl, style=codeStyle]{../perl/helloworld.pl}

To execute it in command-line:
\begin{lstlisting}[style=shellStyle]
$ perl helloworld.perl
\end{lstlisting}

\subsection{PHP}

PHP is a scripting language; the instructions are written directly without a main class or a main function.
A code in PHP is delimited by ``<?php" and ``?>"

\lstinputlisting[language=PHP, style=codeStyle]{../php/helloworld.php}

To execute it in command-line:
\begin{lstlisting}[style=shellStyle]
$ php helloworld.php
\end{lstlisting}

\subsection{Python}

Python is a scripting language; the instructions are written directly without a main class or a main function.

\lstinputlisting[language=Python, style=codeStyle]{../python/helloworld.py}

To execute it in command-line:
\begin{lstlisting}[style=shellStyle]
$ python helloworld.py
\end{lstlisting}

\subsection{Ruby}

Ruby is a scripting language; the instructions are written directly without a main class or a main function.

\lstinputlisting[language=Ruby, style=codeStyle]{../ruby/helloworld.rb}

To execute it in command-line:
\begin{lstlisting}[style=shellStyle]
$ ruby helloworld.ruby
\end{lstlisting}

\section{Functions}

Let's take the factorial function as an example. 
We implement the recursive version.  
The program, first, ask the user to introduce an integer number via the keyboard. 
Then it will call our function and print the result. 
We will print the code just for the function and not the entire program.
Please check the code to see how to read the keyboard.

\subsection{C++}

A function, mainly, contains a return type, its name and parameters. 
The language uses \textbf{\{\}} to define instructions blocks.
To return a value, the language uses the keyword \textbf{return}.
Statements end with a semicolon (\textbf{;}).

\lstinputlisting[language=C++, linerange={12-16}, style=codeStyle]{../cpp/func.cpp}

\subsection{Java}

A function contains a modifier, a return type, its name and parameters.
It is always included in a class.
The language uses \textbf{\{\}} to define instructions blocks.
To return a value, the language uses the keyword \textbf{return}.
Statements end with a semicolon (\textbf{;}).

\lstinputlisting[language=Java, linerange={2-2,12-17}, style=codeStyle]{../java/src/Func.java}

\subsection{Javascript}

A function starts with the keyword \textbf{function}, its name and parameters.
The language uses \textbf{\{\}} to define instructions blocks.
To return a value, the language uses the keyword \textbf{return}.
Statements end with a semicolon (\textbf{;}).

\lstinputlisting[style=codeStyle]{../javascript/func.js}

\subsection{Lua}

A function starts with the keyword \textbf{function}, its name and parameters.
All blocks are ended with the keyword \textbf{end}.
To return a value, the language uses the keyword \textbf{return}.
Each line contains at most one statement, but it can contains many separated by a semicolon.

\lstinputlisting[language={[5.2]Lua}, linerange={1-6}, style=codeStyle]{../lua/func.lua}

\subsection{Perl}

A function starts with the keyword \textbf{sub} and its name.
The parameters can be recovered by shifting them from an array \textbf{@\_}.
The language uses \textbf{\{\}} to define instructions blocks.
To return a value, the language uses the keyword \textbf{return}.
Statements end with a semicolon (\textbf{;}).

\lstinputlisting[language=Perl, linerange={7-13}, style=codeStyle]{../perl/func.pl}

\subsection{PHP}

A function starts with the keyword \textbf{function},its name and parameters.
The language uses \textbf{\{\}} to define statements blocks.
To return a value, the language uses the keyword \textbf{return}.
Statements end with a semicolon (\textbf{;}).

\lstinputlisting[language=PHP, linerange={2-6}, style=codeStyle]{../php/func.php}

\subsection{Python}

A function starts with the keyword \textbf{def},its name and parameters.
The language uses indentation to define statements blocks.
To return a value, the language uses the keyword \textbf{return}.
Each line contains at most one statement, but simple statements can be separated by a semicolon.

\lstinputlisting[language=Python, linerange={12-15}, style=codeStyle]{../python/func.py}

\subsection{Ruby}

A function starts with the keyword \textbf{def},its name and parameters.
All blocks are ended with the keyword \textbf{end}.
To return a value, you can either use the keyword \textbf{return} or put the value directly in a line.
Each line contains at most one statement, but simple statements can be separated by a semicolon.

\lstinputlisting[language=Ruby, linerange={9-15}, style=codeStyle]{../ruby/func.rb}


\section{Entry point}

When a program is called from command-line, it searches for a function as entry-point. 
This is not the case for all languages; for instance, scripting languages execute without needing one. 
Nevertheless, they need a mechanism to recover the command-line parameters. 
Also, some languages, such as Python, afford a main function for entry-point lovers.

\subsection{C++}

In C++, main function is obligatory,  it can have parameters or not. 
The return type is an integer which indicates how the program exited. 
The normal state is 0; Otherwise, it indicates that there was an error during the process.
Contrary to C, in C++ you do not need to return explicitly.
In this case, the return value is an implicit 0.
\begin{lstlisting}[language=C++, style=codeStyle]
int main()
int main(int argc, char * argv[])
\end{lstlisting}

When we want to recover command-line parameters, we have to use the main with arguments. 
\begin{itemize}
	\item argv: is a table of pointers on chars (a table of strings).
	\item argc: is the size of that table
\end{itemize}

\lstinputlisting[language=C++, linerange={1-17}, style=codeStyle]{../cpp/entry.cpp}

The header of our function \textbf{fact} is put ahead of the main, so we can use it. 
The compiler needs function declarations before the point of use. 
In our case, the implementation is after the main function.

%\subsection{Java}
%
%\lstinputlisting[language=Java, style=codeStyle]{../java/src/Func.java}
%
%\subsection{Javascript}
%
%\lstinputlisting[style=codeStyle]{../javascript/func.js}
%
%\subsection{Lua}
%
%\lstinputlisting[language={[5.2]Lua}, style=codeStyle]{../lua/func.lua}
%
%\subsection{Perl}
%
%\lstinputlisting[language=Perl, style=codeStyle]{../perl/func.pl}
%
%\subsection{PHP}
%
%\lstinputlisting[language=PHP, style=codeStyle]{../php/func.php}
%
%\subsection{Python}
%
%\lstinputlisting[language=Python, style=codeStyle]{../python/func.py}
%
%\subsection{Ruby}
%
%\lstinputlisting[language=Ruby, style=codeStyle]{../ruby/func.rb}

\section{Exceptions}

\subsection{C++}

In C++, exceptions can be of any type. 
They are thrown using the keyword \textbf{throw}, and handled using \textbf{try} and \textbf{catch}.

\lstinputlisting[language=C++, style=codeStyle]{../cpp/except.cpp}

If you want to specify the type of the exception, here comes the OOP solution. 
You have to define new types by inheritance from \textbf{std::exception}. 
Then, redefine the function \textbf{what()}.

\lstinputlisting[language=C++, firstline=3, lastline=16, style=codeStyle]{../cpp/except2.cpp}

The exceptions can be thrown by creating a new instance of the defined classes. 

\lstinputlisting[language=C++, firstline=19, lastline=20, style=codeStyle]{../cpp/except2.cpp}

We catch them either by they parent's type, or by catching each type apart. 

\lstinputlisting[language=C++, firstline=35, lastline=41, style=codeStyle]{../cpp/except2.cpp}


\subsection{Java}

\lstinputlisting[language=Java, firstline=4, lastline=15, style=codeStyle]{../java/src/Except.java}

\lstinputlisting[language=Java, firstline=17, lastline=26, style=codeStyle]{../java/src/Except.java}

\lstinputlisting[language=Java, firstline=30, lastline=36, style=codeStyle]{../java/src/Except.java}

\lstinputlisting[language=Java, firstline=40, lastline=53, style=codeStyle]{../java/src/Except.java}

\subsection{Javascript}

\lstinputlisting[language=Java, firstline=18, lastline=21, style=codeStyle]{../javascript/except.js}

\lstinputlisting[language=Java, firstline=10, lastline=16, style=codeStyle]{../javascript/except.js}

\subsection{Lua}

As mentioned in Lua manual, you do not need error handling for most applications. 
To throw an error, you can use the function \textbf{error}

\lstinputlisting[language={[5.2]Lua}, firstline=1, lastline=3, style=codeStyle]{../lua/except.lua}

Then, if you want to handle this error, you can use the function \textbf{pcall} to encapsulate your previous code. 
It will return a success indicator and the returned value from your function.
The value, here, is either the result from te function or the raised error. 

\lstinputlisting[language={[5.2]Lua}, firstline=16, lastline=21, style=codeStyle]{../lua/except.lua}

\subsection{Perl}

One mechanism to throw errors is using the keyword \textbf{die}. 

\lstinputlisting[language=Perl, firstline=14, lastline=17, style=codeStyle]{../perl/except.pl}

Using \textbf{eval}, you can capture the error into \textbf{\$@}.

\lstinputlisting[language=Perl, firstline=6, lastline=12, style=codeStyle]{../perl/except.pl}

\subsection{PHP}

In PHP, Exception handling is available in version 5 and greater.
To raise an exception, either you create an instance of the class \textbf{Exception} with a message as parameter, 
or you create custom exceptions by inheriting from that class.

\lstinputlisting[language=PHP, firstline=4, lastline=14, style=codeStyle]{../php/except.php}

To raise the exception, all you have to do is calling the keyword \textbf{throw} followed by an instance of the custom exception.

\lstinputlisting[language=PHP, firstline=16, lastline=18, style=codeStyle]{../php/except.php}

Then, to capture the exception, you can use \textbf{try} and \textbf{catch}.

\lstinputlisting[language=PHP, firstline=30, lastline=39, style=codeStyle]{../php/except.php}

\subsection{Python}

\lstinputlisting[language=Python, firstline=6, lastline=12, style=codeStyle]{../python/except.py}

\lstinputlisting[language=Python, firstline=14, lastline=18, style=codeStyle]{../python/except.py}

\lstinputlisting[language=Python, firstline=28, lastline=32, style=codeStyle]{../python/except.py}

\lstinputlisting[language=Python, firstline=34, lastline=38, style=codeStyle]{../python/except.py}

\subsection{Ruby}

In Ruby, you can raise an exception giving just a message creating a new instance of \textbf{RuntimeError}. 

\lstinputlisting[language=Python, firstline=1, lastline=12, style=codeStyle]{../ruby/except.rb}

To handle the exception, you can use the keywords: 
\begin{itemize}
	\item begin: to begin the block
	\item rescue: to process the exception (you may have many of this)
	\item else: executes if there was no exception
	\item ensure: executes always in the end
	\item end: to close the block
\end{itemize}

\lstinputlisting[language=Python, firstline=21, lastline=28, style=codeStyle]{../ruby/except.rb}

You can specify custom classes to handle exceptions. 
In here, I regrouped all the exceptions in one module.

\lstinputlisting[language=Python, firstline=1, lastline=12, style=codeStyle]{../ruby/except2.rb}

To raise them, create an instance

\lstinputlisting[language=Python, firstline=16, lastline=19, style=codeStyle]{../ruby/except2.rb}

You can capture them by their parent exception class \textbf{Exception}, or each by its class.

\lstinputlisting[language=Python, firstline=37, lastline=40, style=codeStyle]{../ruby/except.rb}




%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================