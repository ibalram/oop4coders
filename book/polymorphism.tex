%=====================================================================
\ifx\wholebook\relax\else
	\documentclass{KodeBook}
	\input{calls}
	\begin{document}
\fi
%=====================================================================

\chapter{Polymorphism}

\begin{introduction}
	\lettrine{P}{olymorphism} is another key concept of \ac{oop}. 
	In general, the term refers to the ability to assign a different meaning or usage to something in many contexts.
	Hence, it is not a concept specific to \ac{oop} since you can find other forms such as parametric polymorphism (generic programming). 
	In languages with type inheritance, an object of a class can be considered as an object of its superclass; and therefore, the same applications can be executed on it.
	Some languages afford functionalities to verify if a certain object is instantiated from a class, to get its class or to cast the variable using it to another subclass.
	Methods can express polymorphism in two ways: overloading (same name with multiple signatures) and overriding (same signature, different implementation). 
	Not every language affords overloading, but methods overriding is a core task of \ac{oop}.
	Beside \ac{oop} polymorphism, some languages afford some other forms of polymorphism.
\end{introduction} 

\section{Subtype polymorphism}

According to the \nameword{Liskov substitution principle} \citep{1987-liskov}, a function written to take an object of a certain type \textbf{T} must work correctly if passed an object of a type \textbf{S} which is a subtype of \textbf{T}.
C++ and Java are examples of \ac{oop} languages with static type checking affording this principle. 
Some languages do not need an object to be created from a class/prototype extending another to execute certain treatments on it. 
They use a mechanism called \nameword{Duck typing} which states that ``\textit{If it walks like a duck and talks like a duck, it must be a duck}". 

A simple example will be sufficient to show how every language handles such polymorphism. 
Having a class \textbf{Person} with a method \textbf{talk} and two subclasses \textbf{Student} and \textbf{Professor}:
\begin{itemize}
	\item A function \textbf{announce} designed to call \textbf{talk} of \textbf{Person} is passed objects of \textbf{Student} and \textbf{Professor} as argument.
	\item A table intended to contain objects of \textbf{Person} is filled with objects of its subtypes.
	\item If the language supports Duck typing: some unrelated classes and objects having the method \textbf{talk} can be used with the two previous propositions.
\end{itemize}

\subsection{C++}

Lets create our classes

\lstinputlisting[language={[KB]C++}, linerange={4-13}, style=codeStyle]{../codes/cpp/polymorphism/subtype.cpp}

Passing objects of these three classes to a function designed for objects of type \textbf{Person} will work just fine. 

\lstinputlisting[language={[KB]C++}, linerange={15-26, 31-33}, style=codeStyle]{../codes/cpp/polymorphism/subtype.cpp}

Objects of type \textbf{Person} or any other subclass can be assigned to a variable of type \textbf{Person}.

\lstinputlisting[language={[KB]C++}, linerange={20-23, 28-33}, style=codeStyle]{../codes/cpp/polymorphism/subtype.cpp}

\subsection{Java}

Lets create our classes

\lstinputlisting[language={[KB]Java}, linerange={35-40,45-47}, style=codeStyle]{../codes/java/src/polymorphism/Subtype.java}

Passing objects of these three classes to a function designed for objects of type \textbf{Person} will work just fine. 

\lstinputlisting[language={[KB]Java}, linerange={3-7, 13-20, 32-33}, style=codeStyle]{../codes/java/src/polymorphism/Subtype.java}

If we use an interface (\textbf{Machine}) and a function \textbf{announce2} similar to \textbf{announce} but taking as parameter \textbf{Machine} instead of \textbf{Person}, this will work as well because interfaces in Java define new types and support type polymorphism.

\lstinputlisting[language={[KB]Java}, linerange={3-3, 8-8, 13-13, 25-34, 40-44, 48-55}, style=codeStyle]{../codes/java/src/polymorphism/Subtype.java}

Objects of type \textbf{Person} or any other subclass can be assigned to a variable of type \textbf{Person}.

\lstinputlisting[language={[KB]Java}, linerange={3-3, 13-16,22-24,32-33}, style=codeStyle]{../codes/java/src/polymorphism/Subtype.java}

\subsection{Javascript}

Lets create our classes (\ac{es6} style, \ac{es5} code is afforded as well): all of them afford a method \textbf{talk}.

\lstinputlisting[language={[KB]Javascript}, linerange={3-17}, style=codeStyle]{../codes/javascript/polymorphism/es6/subtype.js}

A javascript function does not specify the types of its parameters. 
In this function, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
Because we do not know what type the object is, and if it has a function \textbf{talk}, we can verify before calling it.

\lstinputlisting[language={[KB]Javascript}, linerange={19-23}, style=codeStyle]{../codes/javascript/polymorphism/es6/subtype.js}

Then, objects created from class \textbf{Person} and its subclasses can be passed to \textbf{announce} since they all afford the method \textbf{talk}. 
Also, objects created from a different class (\textbf{Robot}) or created directly containing that method can be passed as well, without causing any problem.
If an object has no method \textbf{talk} (lets say: a number), the function \textbf{announce} will print the other message instead of calling our method.

\lstinputlisting[language={[KB]Javascript}, linerange={25-41}, style=codeStyle]{../codes/javascript/polymorphism/es6/subtype.js}

Lets try a table with different elements 

\lstinputlisting[language={[KB]Javascript}, linerange={43-52}, style=codeStyle]{../codes/javascript/polymorphism/es6/subtype.js}

\subsection{Lua}

Lets create our classes: all of them afford a method \textbf{talk}.
In this code, only the superclass affords the function \textbf{new} by assigning \keyword{self} (the class name) as meta-table of the newly created object(table).  
The benefit of doing this is to not repeat the same \textbf{new} method for subclasses.

\lstinputlisting[language={[KB]Lua}, linerange={1-23}, style=codeStyle]{../codes/lua/polymorphism/subtype.lua}

A lua function does not specify the types of its parameters. 
In \textbf{announce}, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
Because we do not know what type the object is, and if it has a function \textbf{talk}, we can verify if it is a table and if it has a member of type \textbf{function} called \textbf{talk}.

\lstinputlisting[language={[KB]Lua}, linerange={25-32}, style=codeStyle]{../codes/lua/polymorphism/subtype.lua}

Then, objects created from class \textbf{Person} and its subclasses can be passed to \textbf{announce} since they all afford the method \textbf{talk}. 
Also, objects created directly using a table affording the same method can be passed without problem.

\lstinputlisting[language={[KB]Lua}, linerange={34-46}, style=codeStyle]{../codes/lua/polymorphism/subtype.lua}

Lets try a table with different elements 

\lstinputlisting[language={[KB]Lua}, linerange={48-55}, style=codeStyle]{../codes/lua/polymorphism/subtype.lua}

\subsection{Perl}

Lets create our classes: all of them afford a method \textbf{talk} even the one not inheriting from \textbf{Person}.
The \textbf{new} method blesses a hash (our object to be) to the first argument which is the class calling it. 
When other classes inherit \textbf{new}, each will pass its name when calling this method; and therefore, the new object will be blessed to it.

\lstinputlisting[language={[KB]Perl}, linerange={1-17}, style=codeStyle]{../codes/perl/polymorphism/subtype.pl}

A perl subroutine does not specify the types of its parameters and either their number.
In \textbf{announce}, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
Because we do not know what type the object is, we can verify if it has a method called \textbf{talk} using the UNIVERSAL method \keyword[Perl]{can}.

\lstinputlisting[language={[KB]Perl}, linerange={19-24}, style=codeStyle]{../codes/perl/polymorphism/subtype.pl}

Any object created from a class affording \textbf{talk}, or one of its subclasses can be passed to the function \textbf{announce}. 

\lstinputlisting[language={[KB]Perl}, linerange={26-35}, style=codeStyle]{../codes/perl/polymorphism/subtype.pl}

Lets try a table with different elements 

\lstinputlisting[language={[KB]Perl}, linerange={37-42}, style=codeStyle]{../codes/perl/polymorphism/subtype.pl}

\subsection{PHP}

Lets create our classes: all of them afford a method \textbf{talk} either directly or by inheritance.

\lstinputlisting[language={[KB]PHP}, linerange={3-17}, style=codeStyle]{../codes/php/polymorphism/subtype.php}

A PHP function does not specify the types of its parameters. 
In \textbf{announce}, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
So, we have to verify that using a function called \keyword[PHP]{method\_exists}. 

\lstinputlisting[language={[KB]PHP}, linerange={19-23}, style=codeStyle]{../codes/php/polymorphism/subtype.php}

Then, objects created from any class affording the method \textbf{talk} can be passed to \textbf{announce} without a problem. 
If an object has no method \textbf{talk} (lets say: a number), the function \textbf{announce} will print the other message instead of calling our method.

\lstinputlisting[language={[KB]PHP}, linerange={25-34}, style=codeStyle]{../codes/php/polymorphism/subtype.php}

Lets try a table with different elements 

\lstinputlisting[language={[KB]PHP}, linerange={36-45}, style=codeStyle]{../codes/php/polymorphism/subtype.php}

\subsection{Python}

Lets create our classes: all of them afford a method \textbf{talk} either directly or by inheritance.

\lstinputlisting[language={[KB]Python}, linerange={4-14}, style=codeStyle]{../codes/python/polymorphism/subtype.py}

A Python function does not specify the types of its parameters. 
In \textbf{announce}, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
So, we have to retrieve that method using a function called \keyword[Python]{getattr}; if their is no member called \textbf{talk}, the function will return \keyword[Python]{None} as specified in the code.
To verify if it is a method and not a field, we use the function \keyword[Python]{callable}.

\lstinputlisting[language={[KB]Python}, linerange={16-23}, style=codeStyle]{../codes/python/polymorphism/subtype.py}

Then, objects created from any class affording the method \textbf{talk} can be passed to \textbf{announce} without a problem. 
If an object has no method \textbf{talk} (lets say: a number), the function \textbf{announce} will print the other message instead of calling our method.

\lstinputlisting[language={[KB]Python}, linerange={25-34}, style=codeStyle]{../codes/python/polymorphism/subtype.py}

Lets try a table with different elements 

\lstinputlisting[language={[KB]Python}, linerange={36-42}, style=codeStyle]{../codes/python/polymorphism/subtype.py}

%\subsection{Ruby}
%
%\lstinputlisting[language=Ruby, linerange={3-10,19-19}, style=codeStyle]{../ruby/person.rb}
%
%\lstinputlisting[language=Ruby, linerange={3-3,12-19}, style=codeStyle]{../ruby/person.rb}
%
%\lstinputlisting[language=Ruby, linerange={24-26}, style=codeStyle]{../ruby/person.rb}

\section{Type manipulation}

\begin{itemize}
	\item Get object type
	\item Is instance of
	\item casting
\end{itemize}


\section{Methods Overloading}


\section{Methods Overriding}



%\subsection{C++}
%
%\lstinputlisting[language=C++, style=codeStyle]{../cpp/type.cpp}
%
%
%\subsection{Java}
%
%\lstinputlisting[language=Java, style=codeStyle]{../java/src/Type.java}
%
%
%\subsection{Javascript}
%
%\lstinputlisting[linerange={3-4}, style=codeStyle]{../javascript/person.js}
%
%\lstinputlisting[linerange={17-17}, style=codeStyle]{../javascript/person.js}
%
%Methods: 
%
%\lstinputlisting[linerange={1-1,8-15}, style=codeStyle]{../javascript/person.js}
%
%\lstinputlisting[linerange={9-15}, style=codeStyle]{../javascript/person2.js}
%
%getters and setters can be defined using keywords \textbf{get} and \textbf{set} in ES6.
%
%\subsection{Lua}
%
%\lstinputlisting[language={[5.2]Lua}, linerange={4-9}, style=codeStyle]{../lua/person.lua}
%
%\lstinputlisting[language={[5.2]Lua}, linerange={11-17}, style=codeStyle]{../lua/person.lua}
%
%\lstinputlisting[language={[5.2]Lua}, linerange={22-24}, style=codeStyle]{../lua/person.lua}
%
%
%\subsection{Perl}
%
%\lstinputlisting[language=Perl, linerange={10-13}, style=codeStyle]{../perl/person.pl}
%
%\lstinputlisting[language=Perl, linerange={6-6}, style=codeStyle]{../perl/person.pl}
%
%Methods
%
%\lstinputlisting[language=Perl, linerange={25-32}, style=codeStyle]{../perl/person.pl}
%
%\lstinputlisting[language=Perl, linerange={39-41}, style=codeStyle]{../perl/person.pl}

%\subsection{PHP}
%
%\lstinputlisting[language=PHP, linerange={2-7,27-27}, style=codeStyle]{../php/person.php}
%
%\lstinputlisting[language=PHP, linerange={2-2,19-25,27-27}, style=codeStyle]{../php/person.php}
%
%\lstinputlisting[language=PHP, linerange={32-34}, style=codeStyle]{../php/person.php}
%
%\subsection{Python}
%
%\lstinputlisting[language=Python, linerange={4-11}, style=codeStyle]{../python/person.py}
%
%\subsection{Ruby}
%
%\lstinputlisting[language=Ruby, linerange={3-10,19-19}, style=codeStyle]{../ruby/person.rb}
%
%\lstinputlisting[language=Ruby, linerange={3-3,12-19}, style=codeStyle]{../ruby/person.rb}
%
%\lstinputlisting[language=Ruby, linerange={24-26}, style=codeStyle]{../ruby/person.rb}

\section{Not OOP related polymorphism}

\subsection{Operator overloading}

\subsection{Generic programming}

%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================