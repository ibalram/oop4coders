%=====================================================================
\ifx\wholebook\relax\else
	\documentclass{KodeBook}
	\input{calls}
	\begin{document}
\fi
%=====================================================================

\chapter{Polymorphism}

\begin{introduction}
	\lettrine{P}{olymorphism} is another key concept of \ac{oop}. 
	In general, the term refers to the ability to assign a different meaning or usage to something in many contexts.
	Hence, it is not a concept specific to \ac{oop} since you can find other forms such as parametric polymorphism (generic programming). 
	In languages with type inheritance, an object of a class can be considered as an object of its superclass; and therefore, the same applications can be executed on it.
	Some languages afford functionalities to verify if a certain object is instantiated from a class, to get its class or to cast the variable using it to another subclass.
	Methods can express polymorphism in two ways: overloading (same name with multiple signatures) and overriding (same signature, different implementation). 
	Not every language affords overloading, but methods overriding is a core task of \ac{oop}.
	Beside \ac{oop} polymorphism, some languages afford some other forms of polymorphism.
\end{introduction} 

\section{Subtype polymorphism}

According to the \nameword{Liskov substitution principle} \citep{1987-liskov}, a function written to take an object of a certain type \textbf{T} must work correctly if passed an object of a type \textbf{S} which is a subtype of \textbf{T}.
C++ and Java are examples of \ac{oop} languages with static type checking affording this principle. 
Some languages do not need an object to be created from a class/prototype extending another to execute certain treatments on it. 
They use a mechanism called \nameword{Duck typing} which states that ``\textit{If it walks like a duck and talks like a duck, it must be a duck}". 

A simple example will be sufficient to show how every language handles such polymorphism. 
Having a class \textbf{Person} with a method \textbf{talk} and two subclasses \textbf{Student} and \textbf{Professor}:
\begin{itemize}
	\item A function \textbf{announce} designed to call \textbf{talk} of \textbf{Person} is passed objects of \textbf{Student} and \textbf{Professor} as argument.
	\item An array intended to contain objects of \textbf{Person} is filled with objects of its subtypes.
	\item If the language supports Duck typing: some unrelated classes and objects having the method \textbf{talk} can be used with the two previous propositions.
\end{itemize}

\subsection{C++}

Lets create our classes

\lstinputlisting[language={[KB]C++}, linerange={4-13}, style=codeStyle]{../codes/cpp/polymorphism/subtype.cpp}

Passing objects of these three classes to a function designed for objects of type \textbf{Person} will work just fine. 

\lstinputlisting[language={[KB]C++}, linerange={15-26, 31-33}, style=codeStyle]{../codes/cpp/polymorphism/subtype.cpp}

Objects of type \textbf{Person} or any other subclass can be assigned to a variable of type \textbf{Person}.

\lstinputlisting[language={[KB]C++}, linerange={20-23, 28-33}, style=codeStyle]{../codes/cpp/polymorphism/subtype.cpp}

\subsection{Java}

Lets create our classes

\lstinputlisting[language={[KB]Java}, linerange={35-40,45-47}, style=codeStyle]{../codes/java/src/polymorphism/Subtype.java}

Passing objects of these three classes to a function designed for objects of type \textbf{Person} will work just fine. 

\lstinputlisting[language={[KB]Java}, linerange={3-7, 13-20, 32-33}, style=codeStyle]{../codes/java/src/polymorphism/Subtype.java}

If we use an interface (\textbf{Machine}) and a function \textbf{announce2} similar to \textbf{announce} but taking as parameter \textbf{Machine} instead of \textbf{Person}, this will work as well because interfaces in Java define new types and support type polymorphism.

\lstinputlisting[language={[KB]Java}, linerange={3-3, 8-8, 13-13, 25-34, 40-44, 48-55}, style=codeStyle]{../codes/java/src/polymorphism/Subtype.java}

Objects of type \textbf{Person} or any other subclass can be assigned to a variable of type \textbf{Person}.

\lstinputlisting[language={[KB]Java}, linerange={3-3, 13-16,22-24,32-33}, style=codeStyle]{../codes/java/src/polymorphism/Subtype.java}

\subsection{Javascript}

Lets create our classes (\ac{es6} style, \ac{es5} code is afforded as well): all of them afford a method \textbf{talk}.

\lstinputlisting[language={[KB]Javascript}, linerange={3-17}, style=codeStyle]{../codes/javascript/polymorphism/es6/subtype.js}

A javascript function does not specify the types of its parameters. 
In this function, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
Because we do not know what type the object is, and if it has a function \textbf{talk}, we can verify before calling it.

\lstinputlisting[language={[KB]Javascript}, linerange={19-23}, style=codeStyle]{../codes/javascript/polymorphism/es6/subtype.js}

Then, objects created from class \textbf{Person} and its subclasses can be passed to \textbf{announce} since they all afford the method \textbf{talk}. 
Also, objects created from a different class (\textbf{Robot}) or created directly containing that method can be passed as well, without causing any problem.
If an object has no method \textbf{talk} (lets say: a number), the function \textbf{announce} will print the other message instead of calling our method.

\lstinputlisting[language={[KB]Javascript}, linerange={25-41}, style=codeStyle]{../codes/javascript/polymorphism/es6/subtype.js}

Lets try an array with different elements 

\lstinputlisting[language={[KB]Javascript}, linerange={43-52}, style=codeStyle]{../codes/javascript/polymorphism/es6/subtype.js}

\subsection{Lua}

Lets create our classes: all of them afford a method \textbf{talk}.
In this code, only the superclass affords the function \textbf{new} by assigning \keyword{self} (the class name) as meta-table of the newly created object(table).  
The benefit of doing this is to not repeat the same \textbf{new} method for subclasses.

\lstinputlisting[language={[KB]Lua}, linerange={1-23}, style=codeStyle]{../codes/lua/polymorphism/subtype.lua}

A lua function does not specify the types of its parameters. 
In \textbf{announce}, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
Because we do not know what type the object is, and if it has a function \textbf{talk}, we can verify if it is a table and if it has a member of type \textbf{function} called \textbf{talk}.

\lstinputlisting[language={[KB]Lua}, linerange={25-32}, style=codeStyle]{../codes/lua/polymorphism/subtype.lua}

Then, objects created from class \textbf{Person} and its subclasses can be passed to \textbf{announce} since they all afford the method \textbf{talk}. 
Also, objects created directly using a table affording the same method can be passed without problem.

\lstinputlisting[language={[KB]Lua}, linerange={34-46}, style=codeStyle]{../codes/lua/polymorphism/subtype.lua}

Lets try an array with different elements 

\lstinputlisting[language={[KB]Lua}, linerange={48-55}, style=codeStyle]{../codes/lua/polymorphism/subtype.lua}

\subsection{Perl}

Lets create our classes: all of them afford a method \textbf{talk} even the one not inheriting from \textbf{Person}.
The \textbf{new} method blesses a hash (our object to be) to the first argument which is the class calling it. 
When other classes inherit \textbf{new}, each will pass its name when calling this method; and therefore, the new object will be blessed to it.

\lstinputlisting[language={[KB]Perl}, linerange={1-17}, style=codeStyle]{../codes/perl/polymorphism/subtype.pl}

A perl subroutine does not specify the types of its parameters and either their number.
In \textbf{announce}, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
Because we do not know what type the object is, we can verify if it has a method called \textbf{talk} using the UNIVERSAL method \keyword[Perl]{can}.

\lstinputlisting[language={[KB]Perl}, linerange={19-24}, style=codeStyle]{../codes/perl/polymorphism/subtype.pl}

Any object created from a class affording \textbf{talk}, or one of its subclasses can be passed to the function \textbf{announce}. 

\lstinputlisting[language={[KB]Perl}, linerange={26-35}, style=codeStyle]{../codes/perl/polymorphism/subtype.pl}

Lets try an array with different elements 

\lstinputlisting[language={[KB]Perl}, linerange={37-42}, style=codeStyle]{../codes/perl/polymorphism/subtype.pl}

\subsection{PHP}

Lets create our classes: all of them afford a method \textbf{talk} either directly or by inheritance.

\lstinputlisting[language={[KB]PHP}, linerange={3-17}, style=codeStyle]{../codes/php/polymorphism/subtype.php}

A PHP function does not specify the types of its parameters. 
In \textbf{announce}, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
So, we have to verify that using a function called \keyword[PHP]{method\_exists}. 

\lstinputlisting[language={[KB]PHP}, linerange={19-23}, style=codeStyle]{../codes/php/polymorphism/subtype.php}

Then, objects created from any class affording the method \textbf{talk} can be passed to \textbf{announce} without a problem. 
If an object has no method \textbf{talk} (lets say: a number), the function \textbf{announce} will print the other message instead of calling our method.

\lstinputlisting[language={[KB]PHP}, linerange={25-34}, style=codeStyle]{../codes/php/polymorphism/subtype.php}

Lets try an array with different elements 

\lstinputlisting[language={[KB]PHP}, linerange={36-45}, style=codeStyle]{../codes/php/polymorphism/subtype.php}

\subsection{Python}

Lets create our classes: all of them afford a method \textbf{talk} either directly or by inheritance.

\lstinputlisting[language={[KB]Python}, linerange={4-14}, style=codeStyle]{../codes/python/polymorphism/subtype.py}

A Python function does not specify the types of its parameters. 
In \textbf{announce}, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
So, we have to retrieve that method using a function called \keyword[Python]{getattr}; if there is no member called \textbf{talk}, the function will return \keyword[Python]{None} as specified in the code.
To verify if it is a method and not a field, we use the function \keyword[Python]{callable}.

\lstinputlisting[language={[KB]Python}, linerange={16-23}, style=codeStyle]{../codes/python/polymorphism/subtype.py}

Then, objects created from any class affording the method \textbf{talk} can be passed to \textbf{announce} without a problem. 
If an object has no method \textbf{talk} (lets say: a number), the function \textbf{announce} will print the other message instead of calling our method.

\lstinputlisting[language={[KB]Python}, linerange={25-34}, style=codeStyle]{../codes/python/polymorphism/subtype.py}

Lets try an array with different elements 

\lstinputlisting[language={[KB]Python}, linerange={36-42}, style=codeStyle]{../codes/python/polymorphism/subtype.py}

\subsection{Ruby}

Lets create our classes: all of them afford a method \textbf{talk} either directly or by inheritance.

\lstinputlisting[language={[KB]Ruby}, linerange={3-17}, style=codeStyle]{../codes/ruby/polymorphism/subtype.rb}

A Ruby function does not specify the types of its parameters. 
In \textbf{announce}, it is clear that the object named \textbf{talker} must define a method called \textbf{talk}. 
So, we have to verify if the object affords this method using a function \keyword[Ruby]{method\_defined?} which is applied to classes  (we have to retrieve the object's class first).

\lstinputlisting[language={[KB]Ruby}, linerange={19-26}, style=codeStyle]{../codes/ruby/polymorphism/subtype.rb}

Then, objects created from any class affording the method \textbf{talk} can be passed to \textbf{announce} without a problem. 
If an object has no method \textbf{talk} (lets say: a number), the function \textbf{announce} will print the other message instead of calling our method.

\lstinputlisting[language={[KB]Ruby}, linerange={28-37}, style=codeStyle]{../codes/ruby/polymorphism/subtype.rb}

Lets try an array with different elements 

\lstinputlisting[language={[KB]Ruby}, linerange={39-47}, style=codeStyle]{../codes/ruby/polymorphism/subtype.rb}

\section{Type manipulation}

There exists some methods afforded by \ac{oop} languages to manipulate types. 
Even languages with dynamic type checking have some of these methods. 
For each programming language, we will see these points:
\begin{itemize}
	\item \textbf{Get object type}: How to get the type of a given object.
	\item \textbf{Is instance of}: Verify if an object is generated from a class/prototype. 
	\item \textbf{Members existence}: Check if a member (field or method) exists in a given object.
	\item \textbf{Type casts}: Downcasting is the act of changing a reference of a base class to one of its derived class.
	It is useful in case of statically typed languages like C++ and Java.
\end{itemize}

%\subsection{C++}
%
%Lets create our classes
%
%\lstinputlisting[language={[KB]C++}, linerange={4-13}, style=codeStyle]{../codes/cpp/polymorphism/type_manip.cpp}

\subsection{Java}

Lets define some classes

\lstinputlisting[language={[KB]Java}, linerange={66-89}, style=codeStyle]{../codes/java/src/polymorphism/TypeManip.java}

To find the class of an object, you can use the method \keyword[Java]{getClass} inherited from the universal class \keyword[Java]{Object}. 
A class \keyword[Java]{Class} affords a method \keyword[Java]{getName} which returns its name as a \keyword[Java]{String}. 

\lstinputlisting[language={[KB]Java}, linerange={5-5,23-26,31-33,63-64}, style=codeStyle]{../codes/java/src/polymorphism/TypeManip.java}

To verify if an object is an instance of a class, the keyword \keyword[Java]{instanceof} is used.

\lstinputlisting[language={[KB]Java}, linerange={38-45}, style=codeStyle]{../codes/java/src/polymorphism/TypeManip.java}

It is possible to verify if an object has a field or method in Java using reflection. 
You have to import \textbf{java.lang.reflect.*} which contains two classes \keyword[Java]{Method} and \keyword[Java]{Field}. 
A class \keyword[Java]{Class} affords two methods \keyword[Java]{getMethod} which returns a method, and \keyword[Java]{getField} which returns a field. 
These two methods when they cannot find the member in question, they throw an exception. 
To execute a \keyword[Java]{Method}, the method \keyword[Java]{invoke} is used, given the first parameter which is the object affording this method and a list of objects used as parameters. 
Likewise, to recover a value \keyword[Java]{Field}, the method \keyword[Java]{get} which returns an \keyword[Java]{Object}; or you can use other methods which return some other types if you know the type of your field. 
Reflection is not usually used since your methods, mostly, will have a defined typed parameters.

\lstinputlisting[language={[KB]Java}, linerange={6-22}, style=codeStyle]{../codes/java/src/polymorphism/TypeManip.java}

A variable with a type of some class referring an object with a type of its subclass cannot call the subclass's methods. 
If you try to do that, you will have a compiler error telling you that the object does not afford that method.
So, you have to tell the compiler that the variable is, in fact, referencing an object of the subclass. 
This is called: type casting, and more precisely: downcasting.

\lstinputlisting[language={[KB]Java}, linerange={57-62}, style=codeStyle]{../codes/java/src/polymorphism/TypeManip.java}

\section{Methods Overloading}


\section{Methods Overriding}



%\subsection{C++}
%
%\lstinputlisting[language=C++, style=codeStyle]{../cpp/type.cpp}
%
%
%\subsection{Java}
%
%\lstinputlisting[language=Java, style=codeStyle]{../java/src/Type.java}
%
%
%\subsection{Javascript}
%
%\lstinputlisting[linerange={3-4}, style=codeStyle]{../javascript/person.js}
%
%\lstinputlisting[linerange={17-17}, style=codeStyle]{../javascript/person.js}
%
%Methods: 
%
%\lstinputlisting[linerange={1-1,8-15}, style=codeStyle]{../javascript/person.js}
%
%\lstinputlisting[linerange={9-15}, style=codeStyle]{../javascript/person2.js}
%
%getters and setters can be defined using keywords \textbf{get} and \textbf{set} in ES6.
%
%\subsection{Lua}
%
%\lstinputlisting[language={[5.2]Lua}, linerange={4-9}, style=codeStyle]{../lua/person.lua}
%
%\lstinputlisting[language={[5.2]Lua}, linerange={11-17}, style=codeStyle]{../lua/person.lua}
%
%\lstinputlisting[language={[5.2]Lua}, linerange={22-24}, style=codeStyle]{../lua/person.lua}
%
%
%\subsection{Perl}
%
%\lstinputlisting[language=Perl, linerange={10-13}, style=codeStyle]{../perl/person.pl}
%
%\lstinputlisting[language=Perl, linerange={6-6}, style=codeStyle]{../perl/person.pl}
%
%Methods
%
%\lstinputlisting[language=Perl, linerange={25-32}, style=codeStyle]{../perl/person.pl}
%
%\lstinputlisting[language=Perl, linerange={39-41}, style=codeStyle]{../perl/person.pl}

%\subsection{PHP}
%
%\lstinputlisting[language=PHP, linerange={2-7,27-27}, style=codeStyle]{../php/person.php}
%
%\lstinputlisting[language=PHP, linerange={2-2,19-25,27-27}, style=codeStyle]{../php/person.php}
%
%\lstinputlisting[language=PHP, linerange={32-34}, style=codeStyle]{../php/person.php}
%
%\subsection{Python}
%
%\lstinputlisting[language=Python, linerange={4-11}, style=codeStyle]{../python/person.py}
%
%\subsection{Ruby}
%
%\lstinputlisting[language=Ruby, linerange={3-10,19-19}, style=codeStyle]{../ruby/person.rb}
%
%\lstinputlisting[language=Ruby, linerange={3-3,12-19}, style=codeStyle]{../ruby/person.rb}
%
%\lstinputlisting[language=Ruby, linerange={24-26}, style=codeStyle]{../ruby/person.rb}

\section{Not OOP related polymorphism}

\subsection{Operator overloading}

\subsection{Generic programming}

%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================