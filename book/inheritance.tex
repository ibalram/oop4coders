%=====================================================================
\ifx\wholebook\relax\else
	\documentclass{KodeBook}
	\input{calls}
	\begin{document}
		\mainmatter
	
\fi
%=====================================================================

\chapter{Inheritance}

\begin{introduction}
	Inheritance is one of the core concepts of OOP. 
	It enables the definition of a new class called subclass based on an existing one called superclass. 
	This allows us to reuse the visible members of the superclass and add additional members. 
	Many languages create a relationship ``isa" between a subclass and its superclass (which is called subtyping).
	When a class inherits from many superclasses at once, that is called multiple inheritance. 
	This is not possible for all languages, since it leads to many problems such as diamond problem.
\end{introduction} 


\section{Single inheritance}

In this section, we will discuss simple inheritance along with its different implications for each programming language when extending a class:
\begin{itemize}
	\item Do you have to define a constructor for the new subclass? i.e. can the constructor be inherited?
	\item Can we change members visibility?
	\item How to access superclass's and grandparent class's members?
\end{itemize}

\subsection{C++}

If the superclass has the default constructor (without parameters), you do not have to define a constructor explicitly unless you want to include some other initializations. 
If the superclass defines just constructors with parameters, you have to define the constructor of your new subclass. 

\lstinputlisting[language={[KB]C++}, linerange={7-11,13-17}, style=codeStyle]{../codes/cpp/inheritance/single/person.h}

In C++11, you can inherit the constructor using the keyword \keyword{using}; 

\lstinputlisting[language={[KB]C++}, linerange={5-7,9-9,12-12}, style=codeStyle]{../codes/cpp/inheritance/single/professor.h}


In C++, to inherit from a class, you have to define an access mode. 
This access mode can be: public, protected or private.
Public access mode preserve members access as they are. 
As for Protected access mode, public members of the superclass will be considered as protected. 
While Private access mode considers every member of the superclass as private.

\lstinputlisting[language={[KB]C++}, linerange={5-14}, style=codeStyle]{../codes/cpp/inheritance/single/student.h}

Since C++ accepts multiple inheritance, there is no keyword for superclass. 
Instead, you can call a method of the parent or grandparent using their names followed by \keyword{::} then the methods name.

\lstinputlisting[language={[KB]C++}, linerange={3-14}, style=codeStyle]{../codes/cpp/inheritance/single/student.cpp}


\subsection{Java}

When inheriting from a class which has the default constructor (without parameters), you do not have to define a constructor explicitly unless you want to include some other initializations. 
But, if the superclass defines just constructors with parameters, you have to redefine the constructor of your new subclass.

\lstinputlisting[language={[KB]Java}, linerange={3-8,11-13,16-18,20-22}, style=codeStyle]{../codes/java/src/inheritance/single/Person.java}

In this example, if we want to extend the class, we have to define a constructor explicitly. 
This constructor has to call the superclass's explicitly using the keyword \keyword{super}.
This call must be the first thing to do before any other instruction.
Also, we can override its methods and reuse those of the superclass using the keyword \keyword{super}.

\lstinputlisting[language={[KB]Java}, linerange={3-17}, style=codeStyle]{../codes/java/src/inheritance/single/Student.java}

You cannot assign weaker access privileges when overriding a method, but the inverse is permitted. 
As for fields, you cannot override a field. 
If you define a field with the same name as in the superclass, you will still access that of the superclass inside the subclass using the keyword \keyword{super}.

\lstinputlisting[language={[KB]Java}, linerange={3-16}, style=codeStyle]{../codes/java/src/inheritance/single/Professor.java}

If the field of the superclass is public and you define a private field with the same name in its subclass, you will no longer be able to access it outside the subclass.

\lstinputlisting[language={[KB]Java}, linerange={5-11,20-20}, style=codeStyle]{../codes/java/src/inheritance/single/App.java}

You cannot access grandparent's members directly using \keyword{super.super}, you can just access the parent's using \keyword{super}. 

\lstinputlisting[language={[KB]Java}, linerange={5-11,19-19}, style=codeStyle]{../codes/java/src/inheritance/single/GradStudent.java}


\subsection{Javascript} 

In Javascript, all class members are public. 
So, visibility stays as it is when extending a class.

\subsubsection{ECMAScript 5 (ES5)}

Let's define a superclass, where the constructor is a function.

\lstinputlisting[language={[KB]Javascript}, linerange={3-11}, style=codeStyle]{../codes/javascript/inheritance/single/es5/person.js}

To call the superclass's constructor, we use the function \keyword{call} which takes the context of the current object \keyword{this} as its first parameter. 
This will allow the current object to possess the same fields initialized as its superclass.
To inherit the superclass's methods, we must define a subclass prototype similar to that of its superclass.
We must create a new object based on the superclass's prototype and assign it to the new class's prototype. 
Be aware not to assign the superclass's prototype directly (the two prototypes will refer the same object).
If you do, any method you define specific to the subclass will be defined to the superclass too.
After assigning the prototype, you have to set the constructor to the current class because the cloned prototype's constructor will be referring the superclass's constructor.

\lstinputlisting[language={[KB]Javascript}, linerange={5-11}, style=codeStyle]{../codes/javascript/inheritance/single/es5/student.js}

To call a method from the superclass's prototype, you can use the function \keyword{call} by passing the context as first parameter then the rest of parameters. 
In fact, you can call methods of any class even if it is not an ancestor and apply it to the current context, in condition that it uses compatible fields.

\lstinputlisting[language={[KB]Javascript}, linerange={13-16}, style=codeStyle]{../codes/javascript/inheritance/single/es5/student.js}

The constructor of the superclass can be called anywhere inside the subclass's constructor. 
You have to be cautious when doing that, because the fields can be overridden. 
Also, not calling the superclass's constructor will not result in an error. 
But, some fields and initializations may be found missing. 

\lstinputlisting[language={[KB]Javascript}, linerange={5-10}, style=codeStyle]{../codes/javascript/inheritance/single/es5/professor.js}

\subsubsection{ECMAScript 2015 (ES6)}

Classes in new Javascript are primarily syntactical sugar over its existing prototype-based inheritance. 
The class syntax does not introduce a new object-oriented inheritance model to JavaScript.

\lstinputlisting[language={[KB]Javascript}, linerange={1-11}, style=codeStyle]{../codes/javascript/inheritance/single/es6/person.js}

To call the superclass's constructor, we use the keyword \keyword{super}. 
This keyword allows us to access the superclass's methods as well. 

\lstinputlisting[language={[KB]Javascript}, linerange={3-15}, style=codeStyle]{../codes/javascript/inheritance/single/es6/student.js}

Like old Javascript, the constructor of the superclass can be omitted without errors. 
But, some fields which must be defined in the superclass can be absent from the object resulting in malfunctioning of the methods using them.

\lstinputlisting[language={[KB]Javascript}, linerange={3-3}, style=codeStyle]{../codes/javascript/inheritance/single/es6/professor.js}

\subsection{Lua}

To create an instance, you create a new table with default fields representing the class which indexes itself.
The constructor is a method which creates a new object and assign the class as its meta-table.
In our case, the new object will have a field named \textbf{luckyNumber} which is the same as its meta-table (a reference to it).
If you want this object to have its own, you have to set the field using the same name.

\lstinputlisting[language={[KB]Lua}, linerange={1-13}, style=codeStyle]{../codes/lua/inheritance/single/person.lua}

To extend a class, all you have to do it creating the table representing it, then set the superclass as its meta-table. 
In this case, if you call a member (field or method) on this new class and it is not found, it will lookup its meta-table.
You have to create the object from the superclass, so it will contain the same fields, and add specific fields to it.
Then, set the current class as its meta-table; otherwise, the new object will lookup its methods from the superclass and not from the current class.
 
As for calling superclass's methods, you can use the dot call (\keyword{.}) instead of the colon (\keyword{:}) and pass the context (current object, \keyword{self}) as first parameter.

\lstinputlisting[language={[KB]Lua}, linerange={3-17}, style=codeStyle]{../codes/lua/inheritance/single/student.lua}

A fancy method to instantiate a class is to pass an object containing the fields we want it to have to its constructor.
But, if we do not pass a field used by one of its methods, this will result in an error when calling that method.

\lstinputlisting[language={[KB]Lua}, linerange={3-11}, style=codeStyle]{../codes/lua/inheritance/single/professor.lua}

As for accessing other classes' methods, you can call their methods and pass the object as context.

\subsection{Perl}

A class (package here) can extend another using the special variable \keyword{\@ISA}.
In the subclass's constructor, you can create a new object using the superclass's constructor.
This will allow you to have the same fields as the superclass and add specific fields to it.
You can call superclass's methods, including the constructor, using the keyword \keyword{SUPER}. 

\lstinputlisting[language={[KB]Perl}, style=codeStyle]{../codes/perl/inheritance/single/Student.pm}

Like any method, the constructor can be inherited if not overridden. 
The new class will be created similarly to its superclass.

\lstinputlisting[language={[KB]Perl}, style=codeStyle]{../codes/perl/inheritance/single/Professor.pm}

\subsection{PHP}

Lets define a class with some private/public fields and functions. 

\lstinputlisting[language={[KB]PHP}, linerange={2-20}, style=codeStyle]{../codes/php/inheritance/single/person.php}

To extend this class, you have to use the keyword \keyword{extends}. 
To call the superclass's methods, you need to use the keyword \keyword{parent}.

\lstinputlisting[language={[KB]PHP}, linerange={5-19}, style=codeStyle]{../codes/php/inheritance/single/student.php}

If you do not define a constructor for the subclass, it will inherit the constructor of its superclass. 
As for methods visibility, you can pass from more restricted access to less restricted.

\lstinputlisting[language={[KB]PHP}, linerange={5-11}, style=codeStyle]{../codes/php/inheritance/single/professor.php}

If you define a field with the same name as one of the superclass, you actually creating a new field and not overriding the existing one. 
When you do, you can no longer access the superclass's field directly unless you use a getter method with the keyword \keyword{parent}.
Using this keyword, you can access just the superclass's methods and not those of grandparent class.

\lstinputlisting[language={[KB]PHP}, linerange={5-17}, style=codeStyle]{../codes/php/inheritance/single/gradstudent.php}

\subsection{Python}

You can call a superclass method (including the constructor) using two methods:
\begin{itemize}
	\item Using the name of the superclass to call the function and pass the context as first parameter
	\item Using the function \keyword{super} which takes two arguments: the type and the context.
	It returns a proxy object that delegates method calls to a parent or sibling class of type.
\end{itemize}

\lstinputlisting[language={[KB]Python}, linerange={6-17}, style=codeStyle]{../codes/python/inheritance/single/student.py}

A constructor can be inherited; if you do not define one in the subclass, the superclass's will be used. 
The \keyword{pass} statement does nothing; it is required when there is no code to afford.

\lstinputlisting[language={[KB]Python}, linerange={6-7}, style=codeStyle]{../codes/python/inheritance/single/professor.py}

\subsection{Ruby}

You can call a superclass's method (including the constructor) from a method of the same name using the keyword \keyword{super}. 

\lstinputlisting[language={[KB]Ruby}, linerange={3-15}, style=codeStyle]{../codes/ruby/inheritance/single/student.rb}

If the constructor is not defined, the class will inherit its superclass's.
Also, when you override a method, you can change its visibility mode.

\lstinputlisting[language={[KB]Ruby}, linerange={3-9}, style=codeStyle]{../codes/ruby/inheritance/single/professor.rb}

To access a superclass method which does not have the same name, there are two ways:
\begin{itemize}
	\item either by aliasing it before overriding, using \keyword{alias\_method}.
	\item or by binding the current context to a class's method. 
	Using this, you call call even grandparents methods.
\end{itemize}

\lstinputlisting[language={[KB]Ruby}, linerange={4-21}, style=codeStyle]{../codes/ruby/inheritance/single/gradstudent.rb}


\section{Abstract class}

An abstract class is a class which cannot be instantiated, but can be extended.
An abstract method is a method which has to be overridden before it can be used. 

\subsection{C++}

A class is abstract when it has at least one pure virtual method. 
Hence, you cannot have an abstract class with only fields.

\lstinputlisting[language={[KB]C++}, linerange={4-9}, style=codeStyle]{../codes/cpp/inheritance/abst/person.h}

The pure methods must be overridden in the concrete subclasses' (do not forget to override them in the headers). 

\lstinputlisting[language={[KB]C++}, linerange={3-9}, style=codeStyle]{../codes/cpp/inheritance/abst/professor.h}

If a class does not override all abstract methods of its superclass, it will be implicitly considered as abstract. 

\lstinputlisting[language={[KB]C++}, linerange={5-7}, style=codeStyle]{../codes/cpp/inheritance/abst/student.h}


\subsection{Java}

An abstract class is defined by the keyword \keyword{abstract}. 
It does not have to contain an abstract method, which means you can have an abstract class with just fields. 
If the class has at least one abstract method, you have to design it as abstract explicitly.

\lstinputlisting[language={[KB]Java}, linerange={3-12}, style=codeStyle]{../codes/java/src/inheritance/abst/Person.java}

The abstract methods must be overridden in the concrete subclasses

\lstinputlisting[language={[KB]Java}, linerange={3-9}, style=codeStyle]{../codes/java/src/inheritance/abst/Professor.java}

If a class does not override all abstract methods of its superclass, it has to be designed as abstract. 

\lstinputlisting[language={[KB]Java}, linerange={3-4}, style=codeStyle]{../codes/java/src/inheritance/abst/Student.java}

You can instantiate just the non-abstract classes

\lstinputlisting[language={[KB]Java}, linerange={6-9}, style=codeStyle]{../codes/java/src/inheritance/abst/App.java}

\subsection{Javascript} 

There is no abstract classes or methods either in ECMAScript 5 or ECMAScript 2015. 
But, you can prevent instantiating a class by verifying if the new object's constructor is the class's. 
If so, you throw an exception.
As for methods, you throw the exception anyways.

\lstinputlisting[language={[KB]Javascript}, linerange={3-16}, style=codeStyle]{../codes/javascript/inheritance/abst/es5/person.js}

If you want a subclass to be abstract too, you have to do the same thing with its constructor. 
Otherwise, it can be instantiated even if you did not override the abstract method. 
In this case, you cannot call the abstract method or any other method using it. 

\lstinputlisting[language={[KB]Javascript}, linerange={5-10}, style=codeStyle]{../codes/javascript/inheritance/abst/es5/student.js}

\lstinputlisting[language={[KB]Javascript}, linerange={5-14}, style=codeStyle]{../codes/javascript/inheritance/abst/es5/gradstudent.js}

The same analogy goes with ECMAScript 2015 (codes are afforded).

\subsection{Lua}

There are no abstract classes or methods in Lua. 
You can define a method which always throws an error when called, and consider it as abstract.
As for abstract classes, I could not find or think of a mechanism to prevent calling the constructor of a class and creating a new object (table) without preventing it to be called inside a subclass constructor.
You can prevent the new object from calling the class's methods (all of them) by not setting the class as its meta-table. 

\lstinputlisting[language={[KB]Lua}, linerange={1-17}, style=codeStyle]{../codes/lua/inheritance/abst/person.lua}

\subsection{Perl}

You cannot prevent calling the constructor definitely because it has to be called from its subclasses. 
But, you can define the constructor as protected: cannot be accessed unless the caller is a subclass. 
As for methods, you can throw an exception if it is not overridden.

\lstinputlisting[language={[KB]Perl}, style=codeStyle]{../codes/perl/inheritance/abst/Person.pm}

The abstract method must be overridden; if not, there will be errors when calling them.

\lstinputlisting[language={[KB]Perl}, style=codeStyle]{../codes/perl/inheritance/abst/Student.pm}

\subsection{PHP}

Classes defined as abstract may not be instantiated.
To define an abstract method or class, you have to use the keyword \keyword{abstract}.

\lstinputlisting[language={[KB]PHP}, linerange={2-11}, style=codeStyle]{../codes/php/inheritance/abst/person.php}

Any class that contains at least one abstract method, or does not override one, must also be abstract. 

\lstinputlisting[language={[KB]PHP}, linerange={5-5}, style=codeStyle]{../codes/php/inheritance/abst/student.php}

To override an abstract method, you just delete the keyword abstract and afford an implementation.

\lstinputlisting[language={[KB]PHP}, linerange={5-11}, style=codeStyle]{../codes/php/inheritance/abst/professor.php}


\subsection{Python}

To create abstract classes and methods, there exists a module called \nameword{abc} (abstract base classes). 
A class's metaclass can be set to be \keyword{ABCMeta}, but the class can be instantiated unless there is at least one abstract method.
This means, you cannot have an abstract class with just fields. 
An abstract method is marked by the decorator \keyword{\@abstractmethod}.
The abstract methods can have implementations which can be called from the subclasses methods.

\lstinputlisting[language={[KB]Python}, linerange={4-15}, style=codeStyle]{../codes/python/inheritance/abst/person.py}

If all the abstract methods are overridden, the class can be instantiated 

\lstinputlisting[language={[KB]Python}, linerange={6-9}, style=codeStyle]{../codes/python/inheritance/abst/professor.py}

If not all abstract methods are overridden, the new class cannot be instantiated

\lstinputlisting[language={[KB]Python}, linerange={6-7}, style=codeStyle]{../codes/python/inheritance/abst/student.py}

\subsection{Ruby}

There are no abstract classes or methods in Ruby. 
If you want to prohibit instantiating a class, you can raise an exception whenever its constructor is called. 
But, the constructor will not be useful to other subclasses. 
To handle this, you have to verify if the object's class is the current class. 
As for methods, you raise an exception preventing them from being called.

\lstinputlisting[language={[KB]Ruby}, style=codeStyle]{../codes/ruby/inheritance/abst/person.rb}

Even if you don not override the constructor, the subclass will be accessible because the object's class no longer will be the superclass.

\lstinputlisting[language={[KB]Ruby}, linerange={3-9}, style=codeStyle]{../codes/ruby/inheritance/abst/professor.rb}

If you do not override the abstract method, the subclass can be instantiated but the abstract method and the methods using it will raise an exception.

\lstinputlisting[language={[KB]Ruby}, linerange={3-9}, style=codeStyle]{../codes/ruby/inheritance/abst/student.rb}


\section{Final class and method}

A final class is a class which cannot be extended. 
Likewise, a final method is a method which cannot be overridden. 
Having final methods does not imply the class has to be final. 

\subsection{C++}

\subsubsection{Final class}

In early versions, there were no final classes. 
But, there is a hack to prevent subclasses from instantiating; it does not prevent inheriting directly.
You can define a class with a private constructor and a friend type, which means: you cannot instantiate this class but the friend class (type) can. 

\lstinputlisting[language={[KB]C++}, linerange={2-8}, style=codeStyle]{../codes/cpp/inheritance/fin/finalcls1.cpp}

Then, you extend that class to make the subclass final: it can access the constructor of its superclass which means you can instantiate it. 
You can extend that class with no problem, but your new class will be useless since it cannot be instantiated (friend property is not inherited).

\lstinputlisting[language={[KB]C++}, linerange={11-13}, style=codeStyle]{../codes/cpp/inheritance/fin/finalcls1.cpp}

In C++11, life is more easy: just use the keyword \keyword{final} after the class's name. 
In this case, the compiler will complain when you extend a final class.

\lstinputlisting[language={[KB]C++}, linerange={1-3}, style=codeStyle]{../codes/cpp/inheritance/fin/finalcls2.cpp}

\subsubsection{Final method}

In early C++, a method which is not defined as \keyword{virtual} should not be overridden. 
If you try to override it, you actually creating a new method with the same name and hiding the super-method. 
This is not how final methods should act, but the new method will not be accessible from a reference on the superclass (it is not polymorphic).

C++11 comes to the rescue with its new \keyword{final} keyword, which must be positioned in the end of the method's header.
To be final, a method has to be virtual.

\lstinputlisting[language={[KB]C++}, linerange={1-7,14-18,25-25}, style=codeStyle]{../codes/cpp/inheritance/fin/finalmth.cpp}


\subsection{Java}

A final class is marked using the keyword \keyword{final}. 
It cannot be extended, and if you try to extend it you will have a compile error.

\lstinputlisting[language={[KB]Java}, linerange={11-13}, style=codeStyle]{../codes/java/src/inheritance/fin/FinalCls.java}

A final method is also marked using the keyword \keyword{final}. 
It cannot be overridden, otherwise you will have a compile error.

\lstinputlisting[language={[KB]Java}, linerange={18-18,22-27,31-32}, style=codeStyle]{../codes/java/src/inheritance/fin/FinalMth.java}


\subsection{Javascript} 

There is no final classes (objects) in Javascript. 
But, you can limit instantiating to only the current class by verifying if the new objects constructor is the class itself or not. 
This is the inverse of what we did in abstract class.

\lstinputlisting[language={[KB]Javascript}, style=codeStyle]{../codes/javascript/inheritance/fin/es6/finalcls.js}

As for final functions, good luck finding a mechanism to do that!

\subsection{Lua}

%\lstinputlisting[language={[KB]Lua}, linerange={1-6}, style=codeStyle]{../codes/lua/inheritance/app.lua}

\subsection{Perl}

%\lstinputlisting[language={[KB]Perl}, linerange={20-22}, style=codeStyle]{../codes/perl/inheritance/public.pl}

\subsection{PHP}

%\lstinputlisting[language={[KB]PHP}, linerange={3-3,6-6,8-9,17-17}, style=codeStyle]{../codes/php/inheritance/app.php}

\subsection{Python}

%\lstinputlisting[language={[KB]Python}, linerange={4-7, 9-9, 13-13}, style=codeStyle]{../codes/python/inheritance/app.py}

\subsection{Ruby}

%\lstinputlisting[language={[KB]Ruby}, linerange={6-9,14-14,20-20}, style=codeStyle]{../codes/ruby/inheritance/app.rb}



\section{Multiple inheritance}

\subsection{C++}

%\lstinputlisting[language={[KB]C++}, linerange={1-3,6-7,25-26}, style=codeStyle]{../codes/cpp/inheritance/person.h}

\subsection{Java}

%\lstinputlisting[language={[KB]Java}, linerange={1-5,12-12,18-20,27-27,34-34}, style=codeStyle]{../codes/java/src/inheritance/core/Person.java}

\subsection{Javascript} 

%\lstinputlisting[language={[KB]Javascript}, linerange={19-29}, style=codeStyle]{../codes/javascript/inheritance/decorate.js}

\subsection{Lua}

%\lstinputlisting[language={[KB]Lua}, linerange={1-6}, style=codeStyle]{../codes/lua/inheritance/app.lua}

\subsection{Perl}

%\lstinputlisting[language={[KB]Perl}, linerange={20-22}, style=codeStyle]{../codes/perl/inheritance/public.pl}

\subsection{PHP}

%\lstinputlisting[language={[KB]PHP}, linerange={3-3,6-6,8-9,17-17}, style=codeStyle]{../codes/php/inheritance/app.php}

\subsection{Python}

%\lstinputlisting[language={[KB]Python}, linerange={4-7, 9-9, 13-13}, style=codeStyle]{../codes/python/inheritance/app.py}

\subsection{Ruby}

hh

%\lstinputlisting[language={[KB]Ruby}, linerange={6-9,14-14,20-20}, style=codeStyle]{../codes/ruby/inheritance/app.rb}



%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================