%=====================================================================
\ifx\wholebook\relax\else
	\documentclass{KodeBook}
	\input{calls}
	\begin{document}
		\mainmatter
	
\fi
%=====================================================================

\chapter{Inheritance}

\begin{introduction}
	Inheritance is one of the core concepts of OOP. 
	It enables the definition of a new class called subclass based on an existing one called superclass. 
	This allows us to reuse the visible members of the superclass and add additional members. 
	Many languages create a relationship ``isa" between a subclass and its superclass (which is called subtyping).
	When a class inherits from many superclasses at once, that is called multiple inheritance. 
	This is not possible for all languages, since it leads to many problems such as diamond problem.
\end{introduction} 


\section{Single inheritance}

In this section, we will discuss simple inheritance along with its different implications for each programming language when extending a class:
\begin{itemize}
	\item Do you have to define a constructor for the new subclass? i.e. can the constructor be inherited?
	\item Can we change members visibility?
	\item How to access superclass's and grandparent class's members?
\end{itemize}

\subsection{C++}

If the superclass has the default constructor (without parameters), you do not have to define a constructor explicitly unless you want to include some other initializations. 
If the superclass defines just constructors with parameters, you have to define the constructor of your new subclass. 

\lstinputlisting[language={[KB]C++}, linerange={7-11,13-17}, style=codeStyle]{../codes/cpp/inheritance/single/person.h}

In C++11, you can inherit the constructor using the keyword \keyword{using}; 

\lstinputlisting[language={[KB]C++}, linerange={5-7,9-9,12-12}, style=codeStyle]{../codes/cpp/inheritance/single/professor.h}


In C++, to inherit from a class, you have to define an access mode. 
This access mode can be: public, protected or private.
Public access mode preserve members access as they are. 
As for Protected access mode, public members of the superclass will be considered as protected. 
While Private access mode considers every member of the superclass as private.

\lstinputlisting[language={[KB]C++}, linerange={5-14}, style=codeStyle]{../codes/cpp/inheritance/single/student.h}

Since C++ accepts multiple inheritance, there is no keyword for superclass. 
Instead, you can call a method of the parent or grandparent using their names followed by \keyword{::} then the methods name.

\lstinputlisting[language={[KB]C++}, linerange={3-14}, style=codeStyle]{../codes/cpp/inheritance/single/student.cpp}


\subsection{Java}

When inheriting from a class which has the default constructor (without parameters), you do not have to define a constructor explicitly unless you want to include some other initializations. 
But, if the superclass defines just constructors with parameters, you have to redefine the constructor of your new subclass.

\lstinputlisting[language={[KB]Java}, linerange={3-8,11-13,16-18,20-22}, style=codeStyle]{../codes/java/src/inheritance/single/Person.java}

In this example, if we want to extend the class, we have to define a constructor explicitly. 
This constructor has to call the superclass's explicitly using the keyword \keyword{super}.
This call must be the first thing to do before any other instruction.
Also, we can override its methods and reuse those of the superclass using the keyword \keyword{super}.

\lstinputlisting[language={[KB]Java}, linerange={3-17}, style=codeStyle]{../codes/java/src/inheritance/single/Student.java}

You cannot assign weaker access privileges when overriding a method, but the inverse is permitted. 
As for fields, you cannot override a field. 
If you define a field with the same name as in the superclass, you will still access that of the superclass inside the subclass using the keyword \keyword{super}.

\lstinputlisting[language={[KB]Java}, linerange={3-16}, style=codeStyle]{../codes/java/src/inheritance/single/Professor.java}

If the field of the superclass is public and you define a private field with the same name in its subclass, you will no longer be able to access it outside the subclass.

\lstinputlisting[language={[KB]Java}, linerange={5-11,20-20}, style=codeStyle]{../codes/java/src/inheritance/single/App.java}

You cannot access grandparent's members directly using \keyword{super.super}, you can just access the parent's using \keyword{super}. 

\lstinputlisting[language={[KB]Java}, linerange={5-11,19-19}, style=codeStyle]{../codes/java/src/inheritance/single/GradStudent.java}


\subsection{Javascript} 

In Javascript, all class members are public. 
So, visibility stays as it is when extending a class.

\subsubsection{ECMAScript 5 (ES5)}

Let's define a superclass, where the constructor is a function.

\lstinputlisting[language={[KB]Javascript}, linerange={3-11}, style=codeStyle]{../codes/javascript/inheritance/single/es5/person.js}

To call the superclass's constructor, we use the function \keyword{call} which takes the context of the current object \keyword{this} as its first parameter. 
This will allow the current object to possess the same fields initialized as its superclass.
To inherit the superclass's methods, we must define a subclass prototype similar to that of its superclass.
We must create a new object based on the superclass's prototype and assign it to the new class's prototype. 
Be aware not to assign the superclass's prototype directly (the two prototypes will refer the same object).
If you do, any method you define specific to the subclass will be defined to the superclass too.
After assigning the prototype, you have to set the constructor to the current class because the cloned prototype's constructor will be referring the superclass's constructor.

\lstinputlisting[language={[KB]Javascript}, linerange={5-11}, style=codeStyle]{../codes/javascript/inheritance/single/es5/student.js}

To call a method from the superclass's prototype, you can use the function \keyword{call} by passing the context as first parameter then the rest of parameters. 
In fact, you can call methods of any class even if it is not an ancestor and apply it to the current context, in condition that it uses compatible fields.

\lstinputlisting[language={[KB]Javascript}, linerange={13-16}, style=codeStyle]{../codes/javascript/inheritance/single/es5/student.js}

The constructor of the superclass can be called anywhere inside the subclass's constructor. 
You have to be cautious when doing that, because the fields can be overridden. 
Also, not calling the superclass's constructor will not result in an error. 
But, some fields and initializations may be found missing. 

\lstinputlisting[language={[KB]Javascript}, linerange={5-10}, style=codeStyle]{../codes/javascript/inheritance/single/es5/professor.js}

\subsubsection{ECMAScript 2015 (ES6)}

Classes in new Javascript are primarily syntactical sugar over its existing prototype-based inheritance. 
The class syntax does not introduce a new object-oriented inheritance model to JavaScript.

\lstinputlisting[language={[KB]Javascript}, linerange={1-11}, style=codeStyle]{../codes/javascript/inheritance/single/es6/person.js}

To call the superclass's constructor, we use the keyword \keyword{super}. 
This keyword allows us to access the superclass's methods as well. 

\lstinputlisting[language={[KB]Javascript}, linerange={3-15}, style=codeStyle]{../codes/javascript/inheritance/single/es6/student.js}

Like old Javascript, the constructor of the superclass can be omitted without errors. 
But, some fields which must be defined in the superclass can be absent from the object resulting in malfunctioning of the methods using them.

\lstinputlisting[language={[KB]Javascript}, linerange={3-3}, style=codeStyle]{../codes/javascript/inheritance/single/es6/professor.js}

\subsection{Lua}

To create an instance, you create a new table with default fields representing the class which indexes itself.
The constructor is a method which creates a new object and assign the class as its meta-table.
In our case, the new object will have a field named \textbf{luckyNumber} which is the same as its meta-table (a reference to it).
If you want this object to have its own, you have to set the field using the same name.

\lstinputlisting[language={[KB]Lua}, linerange={1-13}, style=codeStyle]{../codes/lua/inheritance/single/person.lua}

To extend a class, all you have to do it creating the table representing it, then set the superclass as its meta-table. 
In this case, if you call a member (field or method) on this new class and it is not found, it will lookup its meta-table.
You have to create the object from the superclass, so it will contain the same fields, and add specific fields to it.
Then, set the current class as its meta-table; otherwise, the new object will lookup its methods from the superclass and not from the current class.
 
As for calling superclass's methods, you can use the dot call (\keyword{.}) instead of the colon (\keyword{:}) and pass the context (current object, \keyword{self}) as first parameter.

\lstinputlisting[language={[KB]Lua}, linerange={3-17}, style=codeStyle]{../codes/lua/inheritance/single/student.lua}

A fancy method to instantiate a class is to pass an object containing the fields we want it to have to its constructor.
But, if we do not pass a field used by one of its methods, this will result in an error when calling that method.

\lstinputlisting[language={[KB]Lua}, linerange={3-11}, style=codeStyle]{../codes/lua/inheritance/single/professor.lua}

As for accessing other classes' methods, you can call their methods and pass the object as context.

\subsection{Perl}

A class (package here) can extend another using the special variable \keyword{\@ISA}.
In the subclass's constructor, you can create a new object using the superclass's constructor.
This will allow you to have the same fields as the superclass and add specific fields to it.
You can call superclass's methods, including the constructor, using the keyword \keyword{SUPER}. 

\lstinputlisting[language={[KB]Perl}, style=codeStyle]{../codes/perl/inheritance/single/Student.pm}

Like any method, the constructor can be inherited if not overridden. 
The new class will be created similarly to its superclass.

\lstinputlisting[language={[KB]Perl}, style=codeStyle]{../codes/perl/inheritance/single/Professor.pm}

\subsection{PHP}

%\lstinputlisting[language={[KB]PHP}, linerange={3-3,6-6,8-9,17-17}, style=codeStyle]{../codes/php/inheritance/app.php}

\subsection{Python}

%\lstinputlisting[language={[KB]Python}, linerange={4-7, 9-9, 13-13}, style=codeStyle]{../codes/python/inheritance/app.py}

\subsection{Ruby}

%\lstinputlisting[language={[KB]Ruby}, linerange={6-9,14-14,20-20}, style=codeStyle]{../codes/ruby/inheritance/app.rb}



\section{Abstract class}

An abstract class is a class which cannot be instantiated, but can be extended.


\subsection{C++}

A class is abstract when it has at least one pure virtual method. 
Hence, you cannot have an abstract class with only fields.

\lstinputlisting[language={[KB]C++}, linerange={4-9}, style=codeStyle]{../codes/cpp/inheritance/abst/person.h}

The pure methods must be overridden in the concrete subclasses' (do not forget to override them in the headers). 

\lstinputlisting[language={[KB]C++}, linerange={3-9}, style=codeStyle]{../codes/cpp/inheritance/abst/professor.h}

If a class does not override all abstract methods of its superclass, it will be implicitly considered as abstract. 

\lstinputlisting[language={[KB]C++}, linerange={5-7}, style=codeStyle]{../codes/cpp/inheritance/abst/student.h}


\subsection{Java}

An abstract class is defined by the keyword \keyword{abstract}. 
It does not have to contain an abstract method, which means you can have an abstract class with just fields. 
If the class has at least one abstract method, you have to design it as abstract explicitly.

\lstinputlisting[language={[KB]Java}, linerange={3-12}, style=codeStyle]{../codes/java/src/inheritance/abst/Person.java}

The abstract methods must be overridden in the concrete subclasses

\lstinputlisting[language={[KB]Java}, linerange={3-9}, style=codeStyle]{../codes/java/src/inheritance/abst/Professor.java}

If a class does not override all abstract methods of its superclass, it has to be designed as abstract. 

\lstinputlisting[language={[KB]Java}, linerange={3-4}, style=codeStyle]{../codes/java/src/inheritance/abst/Student.java}

You can instantiate just the non-abstract classes

\lstinputlisting[language={[KB]Java}, linerange={6-9}, style=codeStyle]{../codes/java/src/inheritance/abst/App.java}

\subsection{Javascript} 

There is no abstract classes or methods either in ECMAScript 5 or ECMAScript 2015. 
But, you can prevent instantiating a class by verifying if the new object's constructor is the class's. 
If so, you throw an exception.
As for methods, you throw the exception anyways.

\lstinputlisting[language={[KB]Javascript}, linerange={3-16}, style=codeStyle]{../codes/javascript/inheritance/abst/es5/person.js}

If you want a subclass to be abstract too, you have to do the same thing with its constructor. 
Otherwise, it can be instantiated even if you did not override the abstract method. 
In this case, you cannot call the abstract method or any other method using it. 

\lstinputlisting[language={[KB]Javascript}, linerange={5-8}, style=codeStyle]{../codes/javascript/inheritance/abst/es5/student.js}

\lstinputlisting[language={[KB]Javascript}, linerange={5-12}, style=codeStyle]{../codes/javascript/inheritance/abst/es5/gradstudent.js}

The same analogy goes with ECMAScript 2015 (codes are afforded).

\subsection{Lua}

There is no abstract classes or methods in Lua. 
You can define a method which always throws an error when called, and consider it as abstract.
As for abstract classes, I could not find or think of a mechanism to prevent calling the constructor of a class and creating a new object (table) without preventing it to be called inside a subclass constructor.
You can prevent the new object from calling the class's methods (all of them) by not setting the class as its meta-table. 

\lstinputlisting[language={[KB]Lua}, linerange={1-17}, style=codeStyle]{../codes/lua/inheritance/abst/person.lua}

\subsection{Perl}

You cannot prevent calling the constructor definitely because it has to be called from its subclasses. 
But, you can define the constructor as protected: cannot be accessed unless the caller is a subclass. 
As for methods, you can throw an exception if it is not overridden.

\lstinputlisting[language={[KB]Perl}, style=codeStyle]{../codes/perl/inheritance/abst/Person.pm}

The abstract method must be overridden; if not, there will be errors when calling them.

\lstinputlisting[language={[KB]Perl}, style=codeStyle]{../codes/perl/inheritance/abst/Student.pm}

\subsection{PHP}

%\lstinputlisting[language={[KB]PHP}, linerange={3-3,6-6,8-9,17-17}, style=codeStyle]{../codes/php/inheritance/app.php}

\subsection{Python}

%\lstinputlisting[language={[KB]Python}, linerange={4-7, 9-9, 13-13}, style=codeStyle]{../codes/python/inheritance/app.py}

\subsection{Ruby}

%\lstinputlisting[language={[KB]Ruby}, linerange={6-9,14-14,20-20}, style=codeStyle]{../codes/ruby/inheritance/app.rb}


\section{Final class}

A final class is a class which cannot be extended. 

\subsection{C++}

%\lstinputlisting[language={[KB]C++}, linerange={1-3,6-7,25-26}, style=codeStyle]{../codes/cpp/inheritance/person.h}

\subsection{Java}

%\lstinputlisting[language={[KB]Java}, linerange={1-5,12-12,18-20,27-27,34-34}, style=codeStyle]{../codes/java/src/inheritance/core/Person.java}

\subsection{Javascript} 

%\lstinputlisting[language={[KB]Javascript}, linerange={19-29}, style=codeStyle]{../codes/javascript/inheritance/decorate.js}

\subsection{Lua}

%\lstinputlisting[language={[KB]Lua}, linerange={1-6}, style=codeStyle]{../codes/lua/inheritance/app.lua}

\subsection{Perl}

%\lstinputlisting[language={[KB]Perl}, linerange={20-22}, style=codeStyle]{../codes/perl/inheritance/public.pl}

\subsection{PHP}

%\lstinputlisting[language={[KB]PHP}, linerange={3-3,6-6,8-9,17-17}, style=codeStyle]{../codes/php/inheritance/app.php}

\subsection{Python}

%\lstinputlisting[language={[KB]Python}, linerange={4-7, 9-9, 13-13}, style=codeStyle]{../codes/python/inheritance/app.py}

\subsection{Ruby}

%\lstinputlisting[language={[KB]Ruby}, linerange={6-9,14-14,20-20}, style=codeStyle]{../codes/ruby/inheritance/app.rb}



\section{Multiple inheritance}

\subsection{C++}

%\lstinputlisting[language={[KB]C++}, linerange={1-3,6-7,25-26}, style=codeStyle]{../codes/cpp/inheritance/person.h}

\subsection{Java}

%\lstinputlisting[language={[KB]Java}, linerange={1-5,12-12,18-20,27-27,34-34}, style=codeStyle]{../codes/java/src/inheritance/core/Person.java}

\subsection{Javascript} 

%\lstinputlisting[language={[KB]Javascript}, linerange={19-29}, style=codeStyle]{../codes/javascript/inheritance/decorate.js}

\subsection{Lua}

%\lstinputlisting[language={[KB]Lua}, linerange={1-6}, style=codeStyle]{../codes/lua/inheritance/app.lua}

\subsection{Perl}

%\lstinputlisting[language={[KB]Perl}, linerange={20-22}, style=codeStyle]{../codes/perl/inheritance/public.pl}

\subsection{PHP}

%\lstinputlisting[language={[KB]PHP}, linerange={3-3,6-6,8-9,17-17}, style=codeStyle]{../codes/php/inheritance/app.php}

\subsection{Python}

%\lstinputlisting[language={[KB]Python}, linerange={4-7, 9-9, 13-13}, style=codeStyle]{../codes/python/inheritance/app.py}

\subsection{Ruby}

hh

%\lstinputlisting[language={[KB]Ruby}, linerange={6-9,14-14,20-20}, style=codeStyle]{../codes/ruby/inheritance/app.rb}



%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================