%=====================================================================
\ifx\wholebook\relax\else
	\documentclass[12pt]{book}
	\input{calls}
	\begin{document}
		\chapter{Introduction to OOP}
\fi
%=====================================================================

\begin{introduction}
	In this chapter, we will present a little history followed by the concepts of OOP.
	Then, we present the benefits of OOP which are arguable whether OOP nowadays has achieve them or not. 
	You can argue that OOP has not afford some benefits it meant to do. 
	The purpose of this book is to be a guide to programmers wanting to compare different implementations of this paradigm. 
	To see how OOP is perceived, we present some point of views from both sides: with and against.
\end{introduction}

\section{History}

%Simula history
Simula is considered the first object-oriented object programming language. 
Simula 67 introduced classes, objects, sub-classes, virtual procedures and dynamic binding.
It was created when \textbf{Kristen Nygaard} saw the need for a better way to represent heterogeneous elements and operations of a system while working on computer simulation programs.
He was joined by \textbf{Ole-Johan Dahl} to create SIMULA I from Norwegian Computing Center in 1962.
%TODO You can add a little code for Simula 67

By the time, while being at the University of Utah, \textbf{Alan Kay} liked the idea behind Simula language. 
He has a vision of a personal computer which provides graphics-oriented applications. 
He sold his vision to \textbf{Xerox Parc} and headed a team to create a personal computer called \textbf{Dynabook} which is programmed using \textbf{Smalltalk}.
The term "object-oriented programming" was coined by Alan Kay referring to objects as the foundation for computation.
In the contrary to simula, classes in smalltalk are objects because everything is an object collaborating with others by exchanging messages.
Alan Kay defines OOP in term of smalltalk as follows: %\citet{1993-kay}
\begin{itemize}
	\item everything is an object
	\item Objects communicate by sending and receiving messages
	\item Objects have their own memory 
	\item Every object is an instance of a class (which must be an object)
	\item The class holds the shared behavior for its instances (in the form of objects in a program list)
	\item To eval a program list, control is passed to the first object and the remainder is treated as its message
\end{itemize}
When asked by \textbf{Stefan Ram} in 2003 on definition of OOP, \textbf{Alan Kay} responded\footnote{\url{http://userpage.fu-berlin.de/~ram/pub/pub_jf47ht81Ht/doc_kay_oop_en}}:
\begin{itemize}
	\item I thought of objects being like biological cells and/or individual computers on a network, only able to communicate with messages.
	\item I wanted to get rid of data.
	\item My math background made me realize that each object could have several algebras associated with it, and there could be families of these, and that these would be very very useful. 
	The term "polymorphism" was imposed much later (I think by \textbf{Peter Wegner}) and it isn't quite valid, since it really comes from the nomenclature of functions, and I wanted quite a bit more than functions. 
	I made up a term "genericity" for dealing with generic behaviors in a quasi-algebraic form.
	\item I didn't like the way Simula I or Simula 67 did inheritance (though I thought Nygaard and Dahl were just tremendous thinkers and designers). So I decided to leave out inheritance as a built-in feature until I understood it better.
\end{itemize}

\begin{kodequote}{Alan Kay (2003)}
	OOP to me means only messaging, local retention and protection and hiding of state-process, and extreme late-binding of all things. 
	It can be done in Smalltalk and in LISP. 
	There are possibly other systems in which this is possible, but I'm not aware of them.
\end{kodequote}

%http://web.eecs.utk.edu/~huangj/CS302S04/notes/oo-intro.html


\section{Concepts}

\subsection{Abstraction}

Abstraction is the process to perceive an entity in the system and some context, then take out unnecessary details and keep those useful to that context.
You can consider it as a generalization of objects.
For example, a person can be represented as an object with some characteristics: first name, last name, birthday, gender, color of eyes, etc. with some behavior: walk, talk, eat, die, etc. 
If we use this person as a student in the context of university, we will no more be needing some aspects: color of eyes, walk, talk, etc. 
Also, we need some other aspects such as: inscription year, grades, etc. 

It is, also, the process to hide internal complex implementation and show only necessary details to the user. 
This will help the user to implement more complex logic using the afforded abstraction without the need to understand how it was implemented.
For example, suppose we have an object called \textbf{car} with some behavior: start, stop, etc. 
Users does not need to know how in detail how the car start moving when they ask it to start; they just need to know what parameters they have to afford.

In term of programming, the different objects sharing same aspects can be represented by a class or a prototype as their abstraction. 
This abstraction will be used to create new objects with the same behavior but with different characteristics. 
Two major styles has raised in OOP world: class-based programming and prototype-based programming.

\subsubsection{Class-based}

In class-based programming, each object is an instance of a class. 
A class may be seen as a template which describes the structure and behavior of its instances.
The object will have: a state (data), a behavior (methods) and identity (unique existence among other objects).
%TODO more

\subsubsection{Prototype-based}

In a prototype-based language, there is no distinction between class and object; there are just objects. 
An object which has its state, behavior and identity can be used as a template to create new objects by cloning and mutation. 
The first prototype-based language is \textbf{self} programming language.

\subsection{Encapsulation}

\subsection{Associations}

\subsection{Inheritance}

\subsection{Polymorphism}


\section{benefits}

%TODO write about these

Simplicity

Readability (throw modularity)

Re-usability

Maintainability: 


\section{limits}

Size 

Effort

Speed (not an issue nowadays)

Learning curve


\section{Some opinions about OOP}

\subsection{Against}

\begin{kodequote}{Edsger W. Dijkstra (1989), TUG LINES Issue 32, August 1989}
	Object-oriented programming is an exceptionally bad idea which could only have originated in California.
\end{kodequote}

\begin{kodequote}{Alan Kay (1997) The Computer Revolution hasn't happened yet}
	I invented the term object-oriented, and I can tell you I did not have C++ in mind.
\end{kodequote}

\begin{kodequote}{Alan Kay (1997) The Computer Revolution hasn't happened yet}
	Java and C++ make you think that the new ideas are like the old ones. Java is the most distressing thing to happen to computing since MS-DOS.
\end{kodequote}

(https://www.cc.gatech.edu/fac/mark.guzdial/squeak/oopsla.html)

\begin{kodequote}{Paul Graham (2003), The Hundred-Year Language}
	Object-oriented programming offers a sustainable way to write spaghetti code.
\end{kodequote}

\begin{kodequote}{Richard Mansfield (2005), Has OOP Failed?}
	With OOP-inflected programming languages, computer software becomes more verbose, less readable, less descriptive, and harder to modify and maintain.
\end{kodequote}

\begin{kodequote}{Eric Raymond (2005), The Art of UNIX Programming}
	The OO design concept initially proved valuable in the design of graphics systems, graphical user interfaces, and certain kinds of simulation. To the surprise and gradual disillusionment of many, it has proven difficult to demonstrate significant benefits of OO outside those areas.
\end{kodequote}

\begin{kodequote}{Jeff Atwood (2007), Your Code: OOP or POO?}
	OO seems to bring at least as many problems to the table as it solves.
\end{kodequote}


\begin{kodequote}{Linus Torvalds (2007)}
	C++ is a horrible language. ... C++ leads to really, really bad design choices. ... In other words, the only way to do good, efficient, and system-level and portable C++ ends up to limit yourself to all the things that are basically available in C. And limiting your project to C means that people don't screw that up, and also means that you get a lot of programmers that do actually understand low-level issues and don't screw things up with any idiotic "object model" crap.
\end{kodequote}

\begin{kodequote}{Joe Armstrong, Coders at Work: Reflections on the Craft of Programming}
	The problem with object-oriented languages is they've got all this implicit environment that they carry around with them. 
	You wanted a banana but what you got was a gorilla holding the banana and the entire jungle.
\end{kodequote}

\begin{kodequote}{Oscar Nierstrasz (2010), Ten Things I Hate About Object-Oriented Programming}
	OOP is about taming complexity through modeling, but we have not mastered this yet, possibly because we have difficulty distinguishing real and accidental complexity.
\end{kodequote}

\begin{kodequote}{Rich Hickey (2010), SE Radio, Episode 158}
	I think that large objected-oriented programs struggle with increasing complexity as you build this large object graph of mutable objects. You know, trying to understand and keep in your mind what will happen when you call a method and what will the side effects be.
\end{kodequote}

\begin{kodequote}{Eric Allman (2011), Programming Isn't Fun Any More}
	I used to be enamored of object-oriented programming. I'm now finding myself leaning toward believing that it is a plot designed to destroy joy. The methodology looks clean and elegant at first, but when you actually get into real programs they rapidly turn into horrid messes.
\end{kodequote}

\begin{kodequote}{Joe Armstrong (2011), Why OO Sucks}
	Objects bind functions and data structures together in indivisible units. I think this is a fundamental error since functions and data structures belong in totally different worlds.
\end{kodequote}

\begin{kodequote}{Rob Pike (2012)}
	Object-oriented programming, whose essence is nothing more than programming using data with associated behaviors, is a powerful idea. It truly is. But it's not always the best idea. ... Sometimes data is just data and functions are just functions.
\end{kodequote}

\begin{kodequote}{John Barker (2013), All evidence points to OOP being bullshit}
	What OOP introduces are abstractions that attempt to improve code sharing and security. In many ways, it is still essentially procedural code.
\end{kodequote}

\begin{kodequote}{Lawrence Krubner (2014)}
	Object Oriented Programming is an expensive disaster which must end
	We now know that OOP is an experiment that failed. It is time to move on. It is time that we, as a community, admit that this idea has failed us, and we must give up on it.
\end{kodequote}

\begin{kodequote}{Asaf Shelly (2015), Flaws of Object Oriented Modeling}
	Reading an object oriented code you can't see the big picture and it is often impossible to review all the small functions that call the one function that you modified.
\end{kodequote}


https://www.infoq.com/presentations/Are-We-There-Yet-Rich-Hickey


\subsection{With}

Grady Booch (1986) Software Engineering with Ada p. 220. cited in: David J. Gilmore et al. (1994) User-Centred Requirements for Software Engineering Environments. p. 108
\begin{kodequote}{Grady Booch (1986) Software Engineering with Ada p. 220. }
	Perhaps the greatest strength of an object-oriented approach to development is that it offers a mechanism that captures a model of the real world.
\end{kodequote}


\begin{kodequote}{Steve Steinberg, "Hype List", Wired, Vol. 1, No. 1, Mar/Apr 1993}
	Anyone even peripherally involved with computers agrees that object-oriented programming (OOP) is the wave of the future. Maybe one in 50 of them has actually tried to use OOP – which has a lot to do with its popularity.
\end{kodequote}

\begin{kodequote}{Allen Wirfs-Brock, in response to the claims that OOP has failed}
	Have you ever look at the programs we were building in the early 1980s? At how limited their functionality and UIs were? OOP has been an incredible success. It enabled us to manage complexity as we grew from 100KB applications to today’s 100MB applications.
\end{kodequote}



%=====================================================================
\ifx\wholebook\relax\else
% \cleardoublepage
% \bibliographystyle{../use/ESIbib}
% \bibliography{../bib/RATstat}
	\end{document}
\fi
%=====================================================================